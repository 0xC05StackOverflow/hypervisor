<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>/home/user/hypervisor/bfunwind/README.md Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">/home/user/hypervisor/bfunwind/README.md</div>  </div>
</div><!--header-->
<div class="contents">
<a href="bfunwind_2_r_e_a_d_m_e_8md.html">Go to the documentation of this file.</a><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;# Unwind Library {#bfunwind_readme}</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;## Description</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;The unwind library is used by C++ to provide exception support. When an exception is thrown in C++, an exception object is created (the object that will be thrown; which is usually something that inherits std::exception), and the stack is unwound until a catch(xxx) statement is found that matches the exception object that was thrown, or the end of the stack is reached in which case std::terminate is called (which in our case results in a call to abort). The code that &quot;unwinds&quot; the stack is the unwind library. On Linux, there are several unwind libraries that can be used with GCC and Clang/LLVM. The three main unwind libraries are libgcc (provided by the GCC compiler), libunwind, and (given the same name) Apple&#39;s libunwind that is now part of the LLVM project.</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;[libgcc](https://github.com/gcc-mirror/gcc/tree/master/libgcc) &lt;br&gt;</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;[libunwind (Savannah)](http://www.nongnu.org/libunwind/) &lt;br&gt;</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;[libunwind (Apple)](https://github.com/llvm-mirror/libunwind) &lt;br&gt;</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;All of these unwind libraries are tightly coupled to user space, and in some cases even require pthread support to work. For this reason, Bareflank provides it&#39;s own unwind library capable of being executed in the kernel, with thread-safety, but with no external dependencies (i.e. not even libc is needed).</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;## How It is Used</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;When the &quot;throw&quot; keyword is used in C++, the compiler actually replaces this with a call to \_\_cxa_allocate, and \_\_cxa_throw. The allocate function allocates the exception object, and the throw performs the stack unwinding. These functions are provided by the C++ ABI. In GCC this would normally be libsupc++. Bareflank currently uses libc++, and thus uses libc++abi instead of libsupc++. The C++ ABI handles most of the C++ specifics, but eventually makes a call to \_\_UnwindRaiseException which is a IA64 C++ ABI specific function call (with it&#39;s own specification) that must be provided by an &quot;unwind&quot; library.</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;[call to \_\_UnwindRaiseException](https://github.com/llvm-mirror/libcxxabi/blob/master/src/cxa_exception.cpp#L195)</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;This library is very specific to the architecture as it usually has to have some raw assembly to perform the &quot;jump&quot; into the function that contains the catch statement (as the registers have to be restored). Currently, Bareflank has support for x86_64, but will eventually have support for ARM 64bit as well.</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;Since &quot;throw&quot; statements in C++ code generate \_\_cxa_xxx function calls, there is no needed to link the unwind library to every single module as they contain symbols for \_\_cxa_xxx and not \_\_UnwindRaiseException. Instead, the unwind library needs to be linked to the libc++abi, and the libc++abi needs to be available at load time. Currently, libc++abi is statically linked to libc++.so, which is loaded by the driver / ELF loader with the rest of the VMM. In future version of Bareflank, libc.so, libc++.so and libc++abi.so will all be loaded by the driver / ELF loader separately and the unwind library will be statically linked to libc++abi.so only.</div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;</div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;The code in the unwind library is organized by the spec that each file implements (since there are multiple specs to get unwinding to work). Generally speaking, when an exception is thrown, the \_\_UnwindRaiseException function is called which is located here:</div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;</div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;[ia64_cxx_abi](https://github.com/Bareflank/hypervisor/blob/master/bfunwind/src/ia64_cxx_abi.cpp)</div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;</div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;The \_\_UnwindRaiseException function saves the register state, and then uses the program counter (i.e. rip for Intel x86_64), and looks up the FDE assocaited with the PC. The FDEs are stored in the &quot;.eh_frame&quot; section in each ELF module. The following code is used to get the FDE:</div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;</div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;[eh_frame](https://github.com/Bareflank/hypervisor/blob/master/bfunwind/src/eh_frame.cpp)</div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;</div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;Once the FDE is located, this code parses the FDE and then uses the DWARF 4 code to decode the stack instructions which unwind the stack for the stack frame the FDE describes. The DWARF code is located here:</div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;</div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;[dwarf4](https://github.com/Bareflank/hypervisor/blob/master/bfunwind/src/dwarf4.cpp)</div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;</div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;The stack is unwound using the DWARF code, and control is handed back to the ia64_cxx_abi which calls a personality function located in the &quot;.text&quot; section in each ELF module which tells the ia64_cxx_abi code if it should continue to unwind, or stop. This process continues until the code is told to stop, in which case the CPU state is updated to reflect the unwound state. For more information and detail on this process, read each header file as it contains a lot more specifics.</div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;</div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;## Limitations</div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;</div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;Currently the unwind library only has support for x86_64, and has only been tested on Intel (although it&#39;s unlikely changes are needed to support AMD64). The unwind library also does not have support for DWARF expressions. Currently expression support has not been needed, but if GCC generates code that does in fact use DWARF expressions, a thrown exception would fail in the unwinder with a call to abort if it&#39;s available. Like the rest of Bareflank, the unwinder assumes that if allocations fail, the system will be halted (i.e. there is no support for gracefully failing an out-of-memory error).</div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;</div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;## Notes</div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;</div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;Since Bareflank makes heavy use of C++ exceptions for handling error conditions, &quot;state&quot; must be handled appropriately. Like other error handling schemes, if an error occurs in the middle of committing state (i.e. writing to member variables, writing to a database, etc...), state changes must be rolled back to provide an all or nothing commit. In C based kernel logic, it&#39;s typical to see a lot of &quot;goto&quot; statements to unroll changes that must be cleaned up if an error occurs. In C++, RAII is used instead (if that term is new to you, google it as it&#39;s an important C++ pattern). To provide automatic rollback logic in the presence of exceptions, a &quot;commit_or_rollback&quot; class is provided in /include.</div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;</div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;[commit_or_rollback](https://github.com/Bareflank/hypervisor/blob/master/include/commit_or_rollback.h)</div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;</div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;The commit_or_rollback code allows you to create a class that will execute a function intended to rollback an operation if that class is not &quot;committed&quot; prior to it&#39;s destruction. A good example of how this works is in the VMXON code:</div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;</div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;[vmxon](https://github.com/Bareflank/hypervisor/blob/master/bfvmm/src/vmxon/src/vmxon_intel_x64.cpp#L35)</div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;</div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;When the VMXON code creates the VMXON region, state has been created. Just prior to creating this region, a commit_or_rollback  (COR) class is created, with a rollback lambda function that releases the region. The last thing the function does it commit the COR. If an error occurs (such as an exception is thrown), the commit function will never be executed, thus when the COR is destroyed, it will execute the rollback function, automatically releasing the VMXON region. These commit_or_rollback function classes will be seen through out the code to ensure that state is handled properly in the event of an error, and can be used by a user of Bareflank to provided similar state guarantees.</div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;</div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;During the development of this code, one bug was found that is worth mentioning here. In the System V spec, the register order is rax, _rdx_, rcx, rbx, etc..., not rax, _rbx_, rcx, rdx. When you read the code, you will see this reflected in the source, and it is by design, as this is how the spec is written, if you change the order of these reigsters to reflect the Intel Manual, the code will not work properly.</div></div><!-- fragment --></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Apr 20 2016 15:38:37 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.12
</small></address>
</body>
</html>
