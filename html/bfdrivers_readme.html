<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Bareflank Drivers</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Bareflank Drivers </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>Description</h2>
<p>The Bareflank drivers (also referred to as the driver entries), are the drivers that load, start, stop, and unload the VMM. The only reason the driver entries are needed is because hypervisor code requires ring 0 to execute (one reason why Apple has created a userspace API for managing hypervisors in ring 3 in OS X). Thus, the driver entries are designed specifically to be as small as possible, with the only code being the IOCTL interface that BFM uses to communicate with the driver entry, as well as the ELF loader used to load and execute the VMM.</p>
<h2>How It is Used</h2>
<p>A Bareflank driver consists of the host OS specific part, and the <a class="el" href="common_8c.html">common.c</a> part. On Linux, this is:</p>
<p><a href="https://github.com/Bareflank/hypervisor/blob/master/bfdrivers/src/arch/linux/entry.c">Linux entry.c</a> <br />
 <a href="https://github.com/Bareflank/hypervisor/blob/master/bfdrivers/src/common.c">Common</a></p>
<p>The host OS part could be from a host OS like Windows or Linux, but also could be a boot environment like UEFI (or BIOS/GRUB if you so inclined to provide legacy support). The <a class="el" href="common_8c.html">common.c</a> part is the bulk of the driver entry, and this code is shared between all of the driver entries, and comes complete with it's own unit test.</p>
<p>When BFM IOCTL's to the driver entry, the host OS part receives the IOCTL, and calls the associated common_xxx logic. Anything that must be done that is host OS specific must be done in the host OS part. For example, currently, Bareflank uses the CR3 page tables setup by BFM when it executes. These page tables are destroyed when BFM finishes it's execution, but are still being used by the VMM (a limitation that will be addressed in version 1.1). To prevent the page tables from being destroyed, the Linux <a class="el" href="entry_8c.html">entry.c</a> saves the BFM context, which must be done outside of the common source code.</p>
<p><a href="https://github.com/Bareflank/hypervisor/blob/master/bfdrivers/src/arch/linux/entry.c#L200">save context</a></p>
<p>To support the unit test for the <a class="el" href="common_8c.html">common.c</a> part, a set of dummy VMM modules were created, each of which provide dummy symbols for required VMM functionality, providing a means to test different combinations for issues that can occur. For example, one test combination loads a set of dummy modules, specifically leaving out a module that has a required symbol, causing the <a class="el" href="common_8c.html">common.c</a> code to enter an error state, and prove that it can handle the error.</p>
<h2>Limitations</h2>
<p>At the moment, the single biggest limitation with the driver entries is the lack of being able to extend them with custom functionality. Since the driver entry is really just a BFM to VMM communication mechanism, our goal is to provide a driver entry that has support for custom messages to the VMM (likely via a hypercall interface to start, but will likely provide more than that in the future).</p>
<p>The driver entries currently do no support multi-core (being addressed in version 1.1), and the driver entries have to save the user space page tables as the VMM does not create it's own (also being addressed in version 1.1).</p>
<h2>Notes</h2>
<p>One issue that you will notice while developing in Bareflank is that a bug in the VMM does not translate well to kernel debuggers. This is because we are manually bootstrapping the VMM's environment inside the kernel, so the kernel has no clue what the VMM code is, or how to handle it when an error occurs. This is why developing with serial, or some other external debugging mechanism (like a PCI debugger) is critical. In some cases, if you do get a valid address as the cause of the error, you can sometimes use that information to figure out where in the code VMM code the crash happened. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Apr 20 2016 15:38:39 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.12
</small></address>
</body>
</html>
