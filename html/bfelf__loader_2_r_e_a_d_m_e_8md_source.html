<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>/home/user/hypervisor/bfelf_loader/README.md Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">/home/user/hypervisor/bfelf_loader/README.md</div>  </div>
</div><!--header-->
<div class="contents">
<a href="bfelf__loader_2_r_e_a_d_m_e_8md.html">Go to the documentation of this file.</a><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;# ELF Loader {#bfelf_loader_readme}</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;## Description</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;When source code is compiled, the compiler must compile the source into a format the OS knows how to load (unless a &quot;flat&quot; binary is being constructed which is outside the scope of this document). On Windows or UEFI the format that is used is PE/COFF, while on Linux, the format is ELF.</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;[ELF64 spec](https://uclibc.org/docs/elf-64-gen.pdf)</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;The entire VMM is a set of shared libraries (also called dynamically linked libraries in Windows), that are compiled to the ELF format using GCC or Clang/LLVM. In fact, the VMM has no &quot;binary&quot; executable like a typical application; everything is a shared library. To load and execute the VMM modules, Bareflank provides a custom ELF loader that can be used in the kernel (currently Linux is supported, but Windows and UEFI support is coming).</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;## How It is Used</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;Although the bulk of the VMM is actually executed in the context of the host OS&#39;s kernel (i.e. the Linux kernel, or UEFI, etc...), the only kernel specific code exists in the /bfdrivers folder which contains Bareflank&#39;s driver entry points.</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;[driver entries](https://github.com/Bareflank/hypervisor/tree/master/bfdrivers/src)</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;Each driver provided by Bareflank provides just enough code to execute Bareflank&#39;s custom ELF loader to load and execute the VMM. Once the VMM is bootstrapped and executed, everything else is done within the VMM, and should be considered an isolated environment. This architecture provides code reuse, while also providing a cross-platform method for writing a hypervisor that can be executed in different host OS kernels (which share pretty much nothing in common).</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;The ELF format provides a ton of information that can be used to better understand what the compiled code should be doing, how to load the code, etc... In the case of Bareflank, the ELF loader needs to be able to load each VMM module into memory, relocate each module (position independent code is heavily used by Bareflank), and then execute it. To better understand how the ELF loader API works, please see the following:</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;[test_bfelf_loader_resolve_symbol_real_test](https://github.com/Bareflank/hypervisor/blob/master/bfelf_loader/test/test_loader_resolve_symbol.cpp#L463)</div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;</div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;How the ELF loader is actually used can be seen in the common.c code for the driver entry points:</div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;</div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;[common.c](https://github.com/Bareflank/hypervisor/blob/master/bfdrivers/src/common.c)</div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;</div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;A summarized explanation of how the VMM is loaded / started is as follows:</div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;- Create an bfelf_file_t for each module that must be loaded and initialize it.</div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;- Allocate memory for each program segment defined by ELF in the module (ELF tells you how much memory to allocate, and what permissions the memory needs; there is likely at least a segment for read/execute, and a segment for read/write for each module).</div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;- Add the initialized ELF file to a bfelf_loader_t.</div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;- Once all ELF files have been added to a loader, relocate. This step processes each symbol in the ELF file&#39;s Global Offset Table (GOT) and makes sure that each symbol is relocated in memory, and has a valid address</div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;- Execute the local_init from the C runtime (see /bfcrt code provided by Bareflank)</div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;- Execute init_vmm()</div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;- Execute start_vmm()</div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;</div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;When the VMM needs to be stopped / unloaded this process is simply reversed.</div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;</div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;The ELF loader is used in other places within Bareflank as well. For example, the ELF loader is used in the unwind library&#39;s unit test to get access to the unit test&#39;s own &quot;.eh_frame&quot; section, which contains information needed to perform stack unwinding.</div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;</div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;[unwind unit test](https://github.com/Bareflank/hypervisor/blob/master/bfunwind/test/test.cpp)</div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;</div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;Like other Bareflank libraries, the ELF loader doesn&#39;t have any external dependencies making it easy to integrate into any kernel but is also capable of being used anywhere ELF is needed.</div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;</div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;## Limitations</div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;</div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;The ELF loader is currently specific to x86_64 for Intel, but will later be extended to support ARM 64bit (a task that might be as simple as relaxing some sanity checks). The loader is currently designed for loading the VMM, but will later be extended if needed to support loading applications into a &quot;VM&quot;.</div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;</div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;## Notes</div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;</div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;The ELF loader has been extensively tested, and was one of the original pieces of code that was developed on this project. In general it can take a lot of abuse, but will crash if you provide an uninitialized structure to it&#39;s APIs. For example, attempting to provide the loader with an ELF file that has not had it&#39;s init function called, and has not been zero&#39;d will result in a crash. The same applies to attempting to use a loader without first zeroing it&#39;s memory. In general, if you create a structure that is used by the ELF loader, you should run memset on that struct (minus the ELF file itself which is zero&#39;d by it&#39;s init function).</div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;</div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;When working with ELF files, if a problem occurs, learning how to use GCC&#39;s readelf command can save you a lot of time (same goes for objdump if things really get out of control). Some typical problems occur when:</div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;- A symbol is missing (ooppsss)</div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;- Duplicate symbols exist, something this ELF loader will not warn you about as duplicate symbols are leveraged so handle with care</div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;- A symbol is mangled differently than you might have anticipated (don&#39;t forget that C++ mangles symbol names while C does not, so you might be missing an export &quot;C&quot; call, or your symbol has a different signature than your expecting).</div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;- Each module has it&#39;s own GOT, so in most cases you will be working with your local GOT reference, and not the one from a different module, so symbol overwriting (as used by Hippomocks) can be tricky</div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;</div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;Finally, it should be noted that there was one code modification made to the ELF loader to support C++ exceptions. When an exception is thrown, libc++abi.so must use std::type_info to figure out if a catch block should actually catch the exception, or tell the unwinder to continue unwinding. In GCC and Clang/LLVM this is done using a pointer comparison (whereas a string compare could and is used on Windows). The pointer comparison is a lot faster, but has the issue that each module will likely have it&#39;s own pointer for each symbol (even if the symbol is the same), thus preventing pointer comparisons from working. To overcome this issue, the IA64 C++ ABI specification, in a small, paragraph, left all by itself to never be heard from again, states that symbols defined as weak should always be given the same address, even across modules. So, C++ exception logic relies on this, and marks all std::type_info symbols as weak. It is then assumed the ELF loader will make sure that all weak symbols have the same pointer across all modules. To support this the Bareflank ELF loader always processes the modules in the same order, and once a symbol is marked weak, a global search is always performed. If the symbol is left marked weak throughout the search, the first address found is used. If a strong reference is found, the search stops, and that address is used instead. This provides the ability to still use the weak / strong relationship, but also provide the same address for all weak references if they occur.</div></div><!-- fragment --></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Apr 20 2016 15:38:37 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.12
</small></address>
</body>
</html>
