<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>C Runtime Library</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">C Runtime Library </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>Description</h2>
<p>Modern compilers provide C runtime libraries designed to aid the compiler in performing certain tasks (for GCC, this is the ctrstuff.c in libgcc). Three different functions that most of these libraries perform:</p><ul>
<li>Global Construction (executing functions defined in the ".ctors" section)</li>
<li>Global Destruction (executing functions defined in the ".dtors" section)</li>
<li>Register Exception Framework Section (".eh_frame" section)</li>
</ul>
<p>Although it is possible for the ELF loader to do these tasks for an executable, from a security / containment perspective, it's better for the executable itself to perform these task's in it's own isolated environment. Bareflank, like everything else, needs to perform these same tasks, and thus performs them in the context of the VMM, but can also use this code within a VM if needed. For Bareflank, all of the C++ objects that are globally defined, have constructors / destructors that need to be executed from a global perspective. Each ".eh_frame" section in the ELF binary also needs to be registered with the unwind code to provide exception support.</p>
<h2>How It's Used</h2>
<p>Each cross compiled shared library is compiled using the bareflank-gcc-wrapper.</p>
<p><a href="https://raw.githubusercontent.com/Bareflank/hypervisor/master/tools/scripts/bareflank-gcc-wrapper">bareflank-gcc-wrapper</a></p>
<p>If you look at a GCC compiler (and even Clang/LLVM), both compilation and linking is done with GCC. When linking is required, GCC calls LD (the linker) on your behalf, and adds ctrbegin.o and crtend.o to your executable (which it gets from ctrstuff.c). These additional object files provide the above described functionality. There are 4 different ELF sections that need to be executed here (two of which we currently support)</p><ul>
<li>ctors</li>
<li>dtors</li>
<li>init_array</li>
<li>fini_array</li>
</ul>
<p>GCC appears to use CTORS/DTORS while Clang/LLVM appears to use init_array /fini_array. These sections are all the same; a list of void (*func)(void) function pointers. When each module is loaded, the CTORS/init_array functions all need to be executed, while during destruction, DTORS/fini_array functions need to be executed. Finally, each ELF module has a ".eh_frame" section (even for C code sometimes), that contains stack unwinding information that is needed by the unwind library. The ELF loader gathers the location and size of each of these sections, which in turn is used by the CRT library to setup/teardown a module:</p>
<p><a href="https://github.com/Bareflank/hypervisor/blob/master/bfelf_loader/src/bfelf_loader.c#L1039">ELF loader</a></p>
<p>To make all of this work, Bareflank's wrapper script acts like GCC and Clang. When "-c" is provided, the code is compiled, and when no "-c" is provided, the code is linked.</p>
<p>The create-cross-compiler.sh script compiles this C runtime library as both a static library and a dynamic library (the dynamic version is not used), and places the library in the "sysroot" which is located in ~/opt/cross/x86_64-elf/. When each shared library is compiled, the gcc wrapper script adds the static C runtime library during linking, which means that every cross compiled shared library has the following two functions added:</p><ul>
<li><a href="https://github.com/Bareflank/hypervisor/blob/master/bfcrt/src/crt.cpp#L26">local_init</a></li>
<li><a href="https://github.com/Bareflank/hypervisor/blob/master/bfcrt/src/crt.cpp#L44">local_fini</a></li>
</ul>
<p>Here is an example of the "entry" module for the VMM that has these symbols added by the wrapper script:</p>
<div class="image">
<img src="https://raw.githubusercontent.com/Bareflank/hypervisor/master/doc/images/local_symbols.png"  width="500"/>
</div>
<p>As you can see, these symbols are marked as global, meaning they have relocation entries, and their addresses can be looked up using the ELF loader. The bareflank drivers (also referred to as the driver entry points, located in the bfdrivers folder), is responsible for loading each cross compiled module from the bfvmm folder into memory using the ELF loader. Once everything is loaded / relocated, the driver then locates the local_init function for each module and executes it.</p>
<p><a href="https://raw.githubusercontent.com/Bareflank/hypervisor/master/bfdrivers/src/common.c">common.c</a></p>
<p>This causes the global constructors to get executed, and registers the ".eh_frame" for the module (to support exception handling). When the driver is "unloading" the VMM, the local_fini function is in turn executed, calling global destructors. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Apr 20 2016 15:38:39 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.12
</small></address>
</body>
</html>
