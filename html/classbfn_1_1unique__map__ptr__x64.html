<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>bfn::unique_map_ptr_x64&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacebfn.html">bfn</a></li><li class="navelem"><a class="el" href="classbfn_1_1unique__map__ptr__x64.html">unique_map_ptr_x64</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">bfn::unique_map_ptr_x64&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:af69513270b79d98429e0a2e5d3486aea"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbfn_1_1unique__map__ptr__x64.html#af69513270b79d98429e0a2e5d3486aea">pointer</a> = T *</td></tr>
<tr class="separator:af69513270b79d98429e0a2e5d3486aea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92cfe59d90d5b8d904b89da53fbc8055"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbfn_1_1unique__map__ptr__x64.html#a92cfe59d90d5b8d904b89da53fbc8055">integer_pointer</a> = uintptr_t</td></tr>
<tr class="separator:a92cfe59d90d5b8d904b89da53fbc8055"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad695851a02f6a2c3a864a65729a8d20d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbfn_1_1unique__map__ptr__x64.html#ad695851a02f6a2c3a864a65729a8d20d">size_type</a> = size_t</td></tr>
<tr class="separator:ad695851a02f6a2c3a864a65729a8d20d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1666a0ee9a684779cc3aa616946740f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbfn_1_1unique__map__ptr__x64.html#ae1666a0ee9a684779cc3aa616946740f">element_type</a> = T</td></tr>
<tr class="separator:ae1666a0ee9a684779cc3aa616946740f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a871ec497d17267b220b56fb041bd3883"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbfn_1_1unique__map__ptr__x64.html#a871ec497d17267b220b56fb041bd3883">unique_map_ptr_x64</a> ()</td></tr>
<tr class="separator:a871ec497d17267b220b56fb041bd3883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a54e86dc4d539ef625f3aff291741fa"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbfn_1_1unique__map__ptr__x64.html#a5a54e86dc4d539ef625f3aff291741fa">unique_map_ptr_x64</a> (std::nullptr_t donotcare)</td></tr>
<tr class="separator:a5a54e86dc4d539ef625f3aff291741fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af921643897d7f5194eea66526101cff0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbfn_1_1unique__map__ptr__x64.html#af921643897d7f5194eea66526101cff0">unique_map_ptr_x64</a> (<a class="el" href="classbfn_1_1unique__map__ptr__x64.html#a92cfe59d90d5b8d904b89da53fbc8055">integer_pointer</a> <a class="el" href="namespacebfn.html#a893578d83bd897a5214b15a6b7c1feeb">virt</a>, <a class="el" href="classbfn_1_1unique__map__ptr__x64.html#ad695851a02f6a2c3a864a65729a8d20d">size_type</a> <a class="el" href="classbfn_1_1unique__map__ptr__x64.html#a783ba038b80a655dd3c666e28bf60091">size</a>)</td></tr>
<tr class="separator:af921643897d7f5194eea66526101cff0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac69b2857a25f16bbb0c642cb3ef4530"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbfn_1_1unique__map__ptr__x64.html#aac69b2857a25f16bbb0c642cb3ef4530">unique_map_ptr_x64</a> (<a class="el" href="classbfn_1_1unique__map__ptr__x64.html#a92cfe59d90d5b8d904b89da53fbc8055">integer_pointer</a> vmap, <a class="el" href="classbfn_1_1unique__map__ptr__x64.html#a92cfe59d90d5b8d904b89da53fbc8055">integer_pointer</a> phys, <a class="el" href="namespacex64_1_1memory__attr.html#af72249a2e77aa3baa79e559e80198763">x64::memory_attr::attr_type</a> attr)</td></tr>
<tr class="separator:aac69b2857a25f16bbb0c642cb3ef4530"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72161f18126128aec4ee9b79ea26c473"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbfn_1_1unique__map__ptr__x64.html#a72161f18126128aec4ee9b79ea26c473">unique_map_ptr_x64</a> (<a class="el" href="classbfn_1_1unique__map__ptr__x64.html#a92cfe59d90d5b8d904b89da53fbc8055">integer_pointer</a> vmap, const std::vector&lt; std::pair&lt; <a class="el" href="classbfn_1_1unique__map__ptr__x64.html#a92cfe59d90d5b8d904b89da53fbc8055">integer_pointer</a>, <a class="el" href="classbfn_1_1unique__map__ptr__x64.html#ad695851a02f6a2c3a864a65729a8d20d">size_type</a> &gt;&gt; &amp;list, <a class="el" href="namespacex64_1_1memory__attr.html#af72249a2e77aa3baa79e559e80198763">x64::memory_attr::attr_type</a> attr)</td></tr>
<tr class="separator:a72161f18126128aec4ee9b79ea26c473"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a540a3911fe0e3a58a9e0e7c5a4b7586e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbfn_1_1unique__map__ptr__x64.html#a540a3911fe0e3a58a9e0e7c5a4b7586e">unique_map_ptr_x64</a> (<a class="el" href="classbfn_1_1unique__map__ptr__x64.html#a92cfe59d90d5b8d904b89da53fbc8055">integer_pointer</a> vmap, <a class="el" href="classbfn_1_1unique__map__ptr__x64.html#a92cfe59d90d5b8d904b89da53fbc8055">integer_pointer</a> <a class="el" href="namespacebfn.html#a893578d83bd897a5214b15a6b7c1feeb">virt</a>, <a class="el" href="classbfn_1_1unique__map__ptr__x64.html#a92cfe59d90d5b8d904b89da53fbc8055">integer_pointer</a> <a class="el" href="namespacebfn.html#a7e7999585651785f03c6103f47a82a30">cr3</a>, <a class="el" href="classbfn_1_1unique__map__ptr__x64.html#ad695851a02f6a2c3a864a65729a8d20d">size_type</a> <a class="el" href="classbfn_1_1unique__map__ptr__x64.html#a783ba038b80a655dd3c666e28bf60091">size</a>, <a class="el" href="namespacex64_1_1msrs.html#afd53a01178e2635e9f3f53f07f44d05c">x64::msrs::value_type</a> <a class="el" href="namespacebfn.html#a4173f1825c39ef59c4e28dee10880dad">pat</a>)</td></tr>
<tr class="separator:a540a3911fe0e3a58a9e0e7c5a4b7586e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4c87b06b079fe8236330e26b9c4b558"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbfn_1_1unique__map__ptr__x64.html#ad4c87b06b079fe8236330e26b9c4b558">unique_map_ptr_x64</a> (<a class="el" href="classbfn_1_1unique__map__ptr__x64.html">unique_map_ptr_x64</a> &amp;&amp;other) <a class="el" href="vmx__intel__x64__mock_8cpp.html#a77ef1e3cf14f172741bc80b259147038">noexcept</a></td></tr>
<tr class="separator:ad4c87b06b079fe8236330e26b9c4b558"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0b9ef217ee51e818ef3d1222905ec4f"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbfn_1_1unique__map__ptr__x64.html#ab0b9ef217ee51e818ef3d1222905ec4f">~unique_map_ptr_x64</a> () <a class="el" href="vmx__intel__x64__mock_8cpp.html#a77ef1e3cf14f172741bc80b259147038">noexcept</a></td></tr>
<tr class="separator:ab0b9ef217ee51e818ef3d1222905ec4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1201a45bc0b5aa72807a120bd8bae82"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbfn_1_1unique__map__ptr__x64.html">unique_map_ptr_x64</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbfn_1_1unique__map__ptr__x64.html#ac1201a45bc0b5aa72807a120bd8bae82">operator=</a> (<a class="el" href="classbfn_1_1unique__map__ptr__x64.html">unique_map_ptr_x64</a> &amp;&amp;other) <a class="el" href="vmx__intel__x64__mock_8cpp.html#a77ef1e3cf14f172741bc80b259147038">noexcept</a></td></tr>
<tr class="separator:ac1201a45bc0b5aa72807a120bd8bae82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10ef62fb1160dac4c80c83830c395bfe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbfn_1_1unique__map__ptr__x64.html">unique_map_ptr_x64</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbfn_1_1unique__map__ptr__x64.html#a10ef62fb1160dac4c80c83830c395bfe">operator=</a> (std::nullptr_t dontcare) <a class="el" href="vmx__intel__x64__mock_8cpp.html#a77ef1e3cf14f172741bc80b259147038">noexcept</a></td></tr>
<tr class="separator:a10ef62fb1160dac4c80c83830c395bfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9890b80c432fb80058ccb1cf782fb71f"><td class="memItemLeft" align="right" valign="top">std::add_lvalue_reference&lt; T &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbfn_1_1unique__map__ptr__x64.html#a9890b80c432fb80058ccb1cf782fb71f">operator*</a> () const</td></tr>
<tr class="separator:a9890b80c432fb80058ccb1cf782fb71f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c2d004a8504c2b552ead8d2abff0711"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbfn_1_1unique__map__ptr__x64.html#a0c2d004a8504c2b552ead8d2abff0711">operator-&gt;</a> () const <a class="el" href="vmx__intel__x64__mock_8cpp.html#a77ef1e3cf14f172741bc80b259147038">noexcept</a></td></tr>
<tr class="separator:a0c2d004a8504c2b552ead8d2abff0711"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a782537f40e14898c99f4c9bdc178251f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbfn_1_1unique__map__ptr__x64.html#af69513270b79d98429e0a2e5d3486aea">pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbfn_1_1unique__map__ptr__x64.html#a782537f40e14898c99f4c9bdc178251f">get</a> () const <a class="el" href="vmx__intel__x64__mock_8cpp.html#a77ef1e3cf14f172741bc80b259147038">noexcept</a></td></tr>
<tr class="separator:a782537f40e14898c99f4c9bdc178251f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8da8d875181dc76fa41827617d7ea27a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbfn_1_1unique__map__ptr__x64.html#a8da8d875181dc76fa41827617d7ea27a">operator bool</a> () const <a class="el" href="vmx__intel__x64__mock_8cpp.html#a77ef1e3cf14f172741bc80b259147038">noexcept</a></td></tr>
<tr class="separator:a8da8d875181dc76fa41827617d7ea27a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a783ba038b80a655dd3c666e28bf60091"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbfn_1_1unique__map__ptr__x64.html#ad695851a02f6a2c3a864a65729a8d20d">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbfn_1_1unique__map__ptr__x64.html#a783ba038b80a655dd3c666e28bf60091">size</a> () const <a class="el" href="vmx__intel__x64__mock_8cpp.html#a77ef1e3cf14f172741bc80b259147038">noexcept</a></td></tr>
<tr class="separator:a783ba038b80a655dd3c666e28bf60091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b35386d2de2c0604a6b33eb8a45013c"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbfn_1_1unique__map__ptr__x64.html#a1b35386d2de2c0604a6b33eb8a45013c">release</a> () <a class="el" href="vmx__intel__x64__mock_8cpp.html#a77ef1e3cf14f172741bc80b259147038">noexcept</a></td></tr>
<tr class="separator:a1b35386d2de2c0604a6b33eb8a45013c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a433383f67c0c72788e9652c6f6d16631"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbfn_1_1unique__map__ptr__x64.html#a433383f67c0c72788e9652c6f6d16631">reset</a> (<a class="el" href="classbfn_1_1unique__map__ptr__x64.html#af69513270b79d98429e0a2e5d3486aea">pointer</a> ptr=<a class="el" href="classbfn_1_1unique__map__ptr__x64.html#af69513270b79d98429e0a2e5d3486aea">pointer</a>(), <a class="el" href="classbfn_1_1unique__map__ptr__x64.html#ad695851a02f6a2c3a864a65729a8d20d">size_type</a> <a class="el" href="classbfn_1_1unique__map__ptr__x64.html#a783ba038b80a655dd3c666e28bf60091">size</a>=<a class="el" href="classbfn_1_1unique__map__ptr__x64.html#ad695851a02f6a2c3a864a65729a8d20d">size_type</a>(), <a class="el" href="classbfn_1_1unique__map__ptr__x64.html#ad695851a02f6a2c3a864a65729a8d20d">size_type</a> unaligned_size=<a class="el" href="classbfn_1_1unique__map__ptr__x64.html#ad695851a02f6a2c3a864a65729a8d20d">size_type</a>()) <a class="el" href="vmx__intel__x64__mock_8cpp.html#a77ef1e3cf14f172741bc80b259147038">noexcept</a></td></tr>
<tr class="separator:a433383f67c0c72788e9652c6f6d16631"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc48a3d46e913ce14180120fac4a0e5a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbfn_1_1unique__map__ptr__x64.html#acc48a3d46e913ce14180120fac4a0e5a">reset</a> (const std::tuple&lt; <a class="el" href="classbfn_1_1unique__map__ptr__x64.html#af69513270b79d98429e0a2e5d3486aea">pointer</a>, <a class="el" href="classbfn_1_1unique__map__ptr__x64.html#ad695851a02f6a2c3a864a65729a8d20d">size_type</a>, <a class="el" href="classbfn_1_1unique__map__ptr__x64.html#ad695851a02f6a2c3a864a65729a8d20d">size_type</a> &gt; &amp;p) <a class="el" href="vmx__intel__x64__mock_8cpp.html#a77ef1e3cf14f172741bc80b259147038">noexcept</a></td></tr>
<tr class="separator:acc48a3d46e913ce14180120fac4a0e5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0728bf963381142c8d31bc99015a0bab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbfn_1_1unique__map__ptr__x64.html#a0728bf963381142c8d31bc99015a0bab">swap</a> (<a class="el" href="classbfn_1_1unique__map__ptr__x64.html">unique_map_ptr_x64</a> &amp;other) <a class="el" href="vmx__intel__x64__mock_8cpp.html#a77ef1e3cf14f172741bc80b259147038">noexcept</a></td></tr>
<tr class="separator:a0728bf963381142c8d31bc99015a0bab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3a294d1d70206b3ef16fd2d00afaae0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbfn_1_1unique__map__ptr__x64.html#aa3a294d1d70206b3ef16fd2d00afaae0">flush</a> () <a class="el" href="vmx__intel__x64__mock_8cpp.html#a77ef1e3cf14f172741bc80b259147038">noexcept</a></td></tr>
<tr class="separator:aa3a294d1d70206b3ef16fd2d00afaae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ef33836dc768edc96db1761f489f16a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbfn_1_1unique__map__ptr__x64.html#a3ef33836dc768edc96db1761f489f16a">cache_flush</a> () <a class="el" href="vmx__intel__x64__mock_8cpp.html#a77ef1e3cf14f172741bc80b259147038">noexcept</a></td></tr>
<tr class="separator:a3ef33836dc768edc96db1761f489f16a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8125d157b371250c4b4fb7148b11b340"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbfn_1_1unique__map__ptr__x64.html#a8125d157b371250c4b4fb7148b11b340">unique_map_ptr_x64</a> (const <a class="el" href="classbfn_1_1unique__map__ptr__x64.html">unique_map_ptr_x64</a> &amp;)=delete</td></tr>
<tr class="separator:a8125d157b371250c4b4fb7148b11b340"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ace82f1294845dab56ca65e79b3cc44"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbfn_1_1unique__map__ptr__x64.html">unique_map_ptr_x64</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbfn_1_1unique__map__ptr__x64.html#a2ace82f1294845dab56ca65e79b3cc44">operator=</a> (const <a class="el" href="classbfn_1_1unique__map__ptr__x64.html">unique_map_ptr_x64</a> &amp;)=delete</td></tr>
<tr class="separator:a2ace82f1294845dab56ca65e79b3cc44"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class T&gt;<br />
class bfn::unique_map_ptr_x64&lt; T &gt;</h3>

<p>Unique Map</p>
<p>Like std::unique_ptr, <a class="el" href="classbfn_1_1unique__map__ptr__x64.html">unique_map_ptr_x64</a> is a smart map that owns and manages the mapping between virtual and physical memory. Memory is mapped when the <a class="el" href="classbfn_1_1unique__map__ptr__x64.html">unique_map_ptr_x64</a> is first created, and unmapped when the <a class="el" href="classbfn_1_1unique__map__ptr__x64.html">unique_map_ptr_x64</a> is destroyed.</p>
<p>Although this class can be used directly, it should be created using make_unique_map_x64, which allocates the virtual memory for you as shown in this example:</p>
<p><b>Example:</b> <br />
</p><div class="fragment"><div class="line">std::cout &lt;&lt; bfn::make_unique_map_x64&lt;char&gt;(phys) &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div></div><!-- fragment --><p>Unlike std::unique_pointer, <a class="el" href="classbfn_1_1unique__map__ptr__x64.html">unique_map_ptr_x64</a> takes additional arguments and doesn't support an array syntax. It should also be noted that this class provides some additional helpers specific to a map including a way to get it's size, as well as a means to flush TLB entries associated with this map if needed (although when the map is created, the local TLB is flushed for you, and thus this should only be needed if you share this map with another core) </p>

<p class="definition">Definition at line <a class="el" href="map__ptr__x64_8h_source.html#l00054">54</a> of file <a class="el" href="map__ptr__x64_8h_source.html">map_ptr_x64.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="af69513270b79d98429e0a2e5d3486aea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af69513270b79d98429e0a2e5d3486aea">&#9670;&nbsp;</a></span>pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbfn_1_1unique__map__ptr__x64.html">bfn::unique_map_ptr_x64</a>&lt; T &gt;::<a class="el" href="classbfn_1_1unique__map__ptr__x64.html#af69513270b79d98429e0a2e5d3486aea">pointer</a> =  T*</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="map__ptr__x64_8h_source.html#l00343">343</a> of file <a class="el" href="map__ptr__x64_8h_source.html">map_ptr_x64.h</a>.</p>

</div>
</div>
<a id="a92cfe59d90d5b8d904b89da53fbc8055"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92cfe59d90d5b8d904b89da53fbc8055">&#9670;&nbsp;</a></span>integer_pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbfn_1_1unique__map__ptr__x64.html">bfn::unique_map_ptr_x64</a>&lt; T &gt;::<a class="el" href="classbfn_1_1unique__map__ptr__x64.html#a92cfe59d90d5b8d904b89da53fbc8055">integer_pointer</a> =  uintptr_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="map__ptr__x64_8h_source.html#l00344">344</a> of file <a class="el" href="map__ptr__x64_8h_source.html">map_ptr_x64.h</a>.</p>

</div>
</div>
<a id="ad695851a02f6a2c3a864a65729a8d20d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad695851a02f6a2c3a864a65729a8d20d">&#9670;&nbsp;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbfn_1_1unique__map__ptr__x64.html">bfn::unique_map_ptr_x64</a>&lt; T &gt;::<a class="el" href="classbfn_1_1unique__map__ptr__x64.html#ad695851a02f6a2c3a864a65729a8d20d">size_type</a> =  size_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="map__ptr__x64_8h_source.html#l00345">345</a> of file <a class="el" href="map__ptr__x64_8h_source.html">map_ptr_x64.h</a>.</p>

</div>
</div>
<a id="ae1666a0ee9a684779cc3aa616946740f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1666a0ee9a684779cc3aa616946740f">&#9670;&nbsp;</a></span>element_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbfn_1_1unique__map__ptr__x64.html">bfn::unique_map_ptr_x64</a>&lt; T &gt;::<a class="el" href="classbfn_1_1unique__map__ptr__x64.html#ae1666a0ee9a684779cc3aa616946740f">element_type</a> =  T</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="map__ptr__x64_8h_source.html#l00346">346</a> of file <a class="el" href="map__ptr__x64_8h_source.html">map_ptr_x64.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a871ec497d17267b220b56fb041bd3883"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a871ec497d17267b220b56fb041bd3883">&#9670;&nbsp;</a></span>unique_map_ptr_x64() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbfn_1_1unique__map__ptr__x64.html">bfn::unique_map_ptr_x64</a>&lt; T &gt;::<a class="el" href="classbfn_1_1unique__map__ptr__x64.html">unique_map_ptr_x64</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Default Map</p>
<p>This constructor can be used to create a default map that maps to nothing </p>

<p class="definition">Definition at line <a class="el" href="map__ptr__x64_8h_source.html#l00353">353</a> of file <a class="el" href="map__ptr__x64_8h_source.html">map_ptr_x64.h</a>.</p>

</div>
</div>
<a id="a5a54e86dc4d539ef625f3aff291741fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a54e86dc4d539ef625f3aff291741fa">&#9670;&nbsp;</a></span>unique_map_ptr_x64() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbfn_1_1unique__map__ptr__x64.html">bfn::unique_map_ptr_x64</a>&lt; T &gt;::<a class="el" href="classbfn_1_1unique__map__ptr__x64.html">unique_map_ptr_x64</a> </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname"><em>donotcare</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Invalid Map</p>
<p>This constructor can be used to create an invalid map that maps to nothing </p>

<p class="definition">Definition at line <a class="el" href="map__ptr__x64_8h_source.html#l00364">364</a> of file <a class="el" href="map__ptr__x64_8h_source.html">map_ptr_x64.h</a>.</p>

</div>
</div>
<a id="af921643897d7f5194eea66526101cff0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af921643897d7f5194eea66526101cff0">&#9670;&nbsp;</a></span>unique_map_ptr_x64() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbfn_1_1unique__map__ptr__x64.html">bfn::unique_map_ptr_x64</a>&lt; T &gt;::<a class="el" href="classbfn_1_1unique__map__ptr__x64.html">unique_map_ptr_x64</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbfn_1_1unique__map__ptr__x64.html#a92cfe59d90d5b8d904b89da53fbc8055">integer_pointer</a>&#160;</td>
          <td class="paramname"><em>virt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbfn_1_1unique__map__ptr__x64.html#ad695851a02f6a2c3a864a65729a8d20d">size_type</a>&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Release Map</p>
<p>This constructor can be used to create a map that maps to an exist virtual address and size. Note that this should be used with case as the original map must be released. Otherwise you will have two owners. </p>

<p class="definition">Definition at line <a class="el" href="map__ptr__x64_8h_source.html#l00377">377</a> of file <a class="el" href="map__ptr__x64_8h_source.html">map_ptr_x64.h</a>.</p>

</div>
</div>
<a id="aac69b2857a25f16bbb0c642cb3ef4530"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac69b2857a25f16bbb0c642cb3ef4530">&#9670;&nbsp;</a></span>unique_map_ptr_x64() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbfn_1_1unique__map__ptr__x64.html">bfn::unique_map_ptr_x64</a>&lt; T &gt;::<a class="el" href="classbfn_1_1unique__map__ptr__x64.html">unique_map_ptr_x64</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbfn_1_1unique__map__ptr__x64.html#a92cfe59d90d5b8d904b89da53fbc8055">integer_pointer</a>&#160;</td>
          <td class="paramname"><em>vmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbfn_1_1unique__map__ptr__x64.html#a92cfe59d90d5b8d904b89da53fbc8055">integer_pointer</a>&#160;</td>
          <td class="paramname"><em>phys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacex64_1_1memory__attr.html#af72249a2e77aa3baa79e559e80198763">x64::memory_attr::attr_type</a>&#160;</td>
          <td class="paramname"><em>attr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Map Single Page</p>
<p>This constructor can be used to map a single virtual memory page to a single physical memory page.</p>
<p><b>Example:</b> <br />
</p><div class="fragment"><div class="line">std::cout &lt;&lt; bfn::make_unique_map_x64&lt;char&gt;(phys) &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div></div><!-- fragment --><dl class="section pre"><dt>Precondition</dt><dd>expects: vmap != 0 </dd>
<dd>
expects: vmap &amp; (<a class="el" href="namespacex64.html#aa0637d39eacac0999c8bba38b6330619">x64::page_size</a> - 1) == 0 </dd>
<dd>
expects: phys != 0 </dd>
<dd>
expects: phys &amp; (<a class="el" href="namespacex64.html#aa0637d39eacac0999c8bba38b6330619">x64::page_size</a> - 1) == 0 </dd>
<dd>
expects: attr != 0 </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>ensures: <a class="el" href="classbfn_1_1unique__map__ptr__x64.html#a782537f40e14898c99f4c9bdc178251f">get()</a> != nullptr</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmap</td><td>the virtual address to map the physical address to </td></tr>
    <tr><td class="paramname">phys</td><td>the physical address to map </td></tr>
    <tr><td class="paramname">attr</td><td>defines how to map the memory. Defaults to map_read_write </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="map__ptr__x64_8h_source.html#l00404">404</a> of file <a class="el" href="map__ptr__x64_8h_source.html">map_ptr_x64.h</a>.</p>

</div>
</div>
<a id="a72161f18126128aec4ee9b79ea26c473"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72161f18126128aec4ee9b79ea26c473">&#9670;&nbsp;</a></span>unique_map_ptr_x64() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbfn_1_1unique__map__ptr__x64.html">bfn::unique_map_ptr_x64</a>&lt; T &gt;::<a class="el" href="classbfn_1_1unique__map__ptr__x64.html">unique_map_ptr_x64</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbfn_1_1unique__map__ptr__x64.html#a92cfe59d90d5b8d904b89da53fbc8055">integer_pointer</a>&#160;</td>
          <td class="paramname"><em>vmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; <a class="el" href="classbfn_1_1unique__map__ptr__x64.html#a92cfe59d90d5b8d904b89da53fbc8055">integer_pointer</a>, <a class="el" href="classbfn_1_1unique__map__ptr__x64.html#ad695851a02f6a2c3a864a65729a8d20d">size_type</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacex64_1_1memory__attr.html#af72249a2e77aa3baa79e559e80198763">x64::memory_attr::attr_type</a>&#160;</td>
          <td class="paramname"><em>attr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Map Physically Contiguous / Non-Contiguous Range</p>
<p>This constructor can be used to map both physically contiguous, and physically non-contiguous memory by providing a list of physical pages to map. The list consists of std::pairs, each containing a physical address, and a size. A physically contiguous memory range would consist of a list of one std::pair contains the physical address and it's size. A physically non-contiguous range would consist of a list of each page range that makes up the memory to be mapped (similar to a Windows MDL). In either case the total number of bytes mapped is equal to the total of each size field in each std::pair in the list provided.</p>
<dl class="section note"><dt>Note</dt><dd>the resulting virtual memory address, like the other constructors, will contain the lower bits of the physical address so that you can not only get a map, but also receive a map somewhere inside of the page if needed.</dd>
<dd>
this function doesn't check to make sure that the physical ranges you provide don't overlap as the mapping will succeed either way, so unless you want the same physical page being mapped to different parts of your virtual range, make sure you don't have overlapping ranges. In some cases you might want that, the best example being ring buffers.</dd></dl>
<p><b>Example:</b> <br />
</p><div class="fragment"><div class="line"><span class="keyword">auto</span> phys_range_1 = std::make_pair(phys1, size1);</div><div class="line"><span class="keyword">auto</span> phys_range_2 = std::make_pair(phys2, size2);</div><div class="line"><span class="keyword">auto</span> phys_range_3 = std::make_pair(phys3, size3);</div><div class="line"><span class="keyword">auto</span> list = {phys_range_1, phys_range_2, phys_range_3};</div><div class="line">std::cout &lt;&lt; bfn::make_unique_map_x64&lt;char&gt;(list) &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div></div><!-- fragment --><dl class="section pre"><dt>Precondition</dt><dd>expects: vmap != 0 </dd>
<dd>
expects: vmap &amp; (<a class="el" href="namespacex64.html#aa0637d39eacac0999c8bba38b6330619">x64::page_size</a> - 1) == 0 </dd>
<dd>
expects: list.empty() == false </dd>
<dd>
expects: list.at(i).first != 0 </dd>
<dd>
expects: list.at(i).second != 0 </dd>
<dd>
expects: list.at(i).second &amp; (<a class="el" href="namespacex64.html#aa0637d39eacac0999c8bba38b6330619">x64::page_size</a> - 1) == 0 </dd>
<dd>
expects: attr != 0 </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>ensures: <a class="el" href="classbfn_1_1unique__map__ptr__x64.html#a782537f40e14898c99f4c9bdc178251f">get()</a> != nullptr</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmap</td><td>the virtual address to map the physical address to </td></tr>
    <tr><td class="paramname">list</td><td>list of std::pairs, each containing a physical address and a size, defining a physical address range to add to the virtual address mapping </td></tr>
    <tr><td class="paramname">attr</td><td>defines how to map the memory. Defaults to map_read_write </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="map__ptr__x64_8h_source.html#l00469">469</a> of file <a class="el" href="map__ptr__x64_8h_source.html">map_ptr_x64.h</a>.</p>

</div>
</div>
<a id="a540a3911fe0e3a58a9e0e7c5a4b7586e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a540a3911fe0e3a58a9e0e7c5a4b7586e">&#9670;&nbsp;</a></span>unique_map_ptr_x64() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbfn_1_1unique__map__ptr__x64.html">bfn::unique_map_ptr_x64</a>&lt; T &gt;::<a class="el" href="classbfn_1_1unique__map__ptr__x64.html">unique_map_ptr_x64</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbfn_1_1unique__map__ptr__x64.html#a92cfe59d90d5b8d904b89da53fbc8055">integer_pointer</a>&#160;</td>
          <td class="paramname"><em>vmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbfn_1_1unique__map__ptr__x64.html#a92cfe59d90d5b8d904b89da53fbc8055">integer_pointer</a>&#160;</td>
          <td class="paramname"><em>virt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbfn_1_1unique__map__ptr__x64.html#a92cfe59d90d5b8d904b89da53fbc8055">integer_pointer</a>&#160;</td>
          <td class="paramname"><em>cr3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbfn_1_1unique__map__ptr__x64.html#ad695851a02f6a2c3a864a65729a8d20d">size_type</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacex64_1_1msrs.html#afd53a01178e2635e9f3f53f07f44d05c">x64::msrs::value_type</a>&#160;</td>
          <td class="paramname"><em>pat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Map Physically Contiguous / Non-Contiguous Range With CR3</p>
<p>This constructor can be used to map both physically contiguous, and physically non-contiguous memory by providing an existing virtually contiguous memory range address and size, as well as the CR3 value that defines the existing virtual to physical memory mappings. This is useful when mapping guest memory into VMM, and caution should be taken if mapping executable memory.</p>
<dl class="section note"><dt>Note</dt><dd>since this function must map in the guest's page tables to locate each physical address for each page being mapped, this function is very expensive, and should not be used in time critical operations.</dd></dl>
<p><b>Example:</b> <br />
</p><div class="fragment"><div class="line">std::cout &lt;&lt; bfn::make_unique_map_x64&lt;char&gt;(<a class="code" href="namespacebfn.html#a893578d83bd897a5214b15a6b7c1feeb">virt</a>, vmcs::guest_cr3::get(), <a class="code" href="classbfn_1_1unique__map__ptr__x64.html#a783ba038b80a655dd3c666e28bf60091">size</a>) &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div></div><!-- fragment --><dl class="section pre"><dt>Precondition</dt><dd>expects: vmap != 0 </dd>
<dd>
expects: vmap &amp; (<a class="el" href="namespacex64.html#aa0637d39eacac0999c8bba38b6330619">x64::page_size</a> - 1) == 0 </dd>
<dd>
expects: virt != 0 </dd>
<dd>
expects: cr3 != 0 </dd>
<dd>
expects: cr3 &amp; (<a class="el" href="namespacex64.html#aa0637d39eacac0999c8bba38b6330619">x64::page_size</a> - 1) == 0 </dd>
<dd>
expects: size != 0 </dd>
<dd>
expects: attr != 0 </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>ensures: <a class="el" href="classbfn_1_1unique__map__ptr__x64.html#a782537f40e14898c99f4c9bdc178251f">get()</a> != nullptr</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmap</td><td>the virtual address to map the range to </td></tr>
    <tr><td class="paramname">virt</td><td>the virtual address containing the existing mapping </td></tr>
    <tr><td class="paramname">cr3</td><td>the root page table containing the existing virtual to physical memory mappings </td></tr>
    <tr><td class="paramname">size</td><td>the number of bytes to map </td></tr>
    <tr><td class="paramname">pat</td><td>the pat msr associated with the provided cr3 </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="map__ptr__x64_8h_source.html#l00542">542</a> of file <a class="el" href="map__ptr__x64_8h_source.html">map_ptr_x64.h</a>.</p>

</div>
</div>
<a id="ad4c87b06b079fe8236330e26b9c4b558"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4c87b06b079fe8236330e26b9c4b558">&#9670;&nbsp;</a></span>unique_map_ptr_x64() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbfn_1_1unique__map__ptr__x64.html">bfn::unique_map_ptr_x64</a>&lt; T &gt;::<a class="el" href="classbfn_1_1unique__map__ptr__x64.html">unique_map_ptr_x64</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbfn_1_1unique__map__ptr__x64.html">unique_map_ptr_x64</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Move Constructor</p>
<p>Like std::unique_ptr, this is equivalent to</p>
<p><b>Example:</b> <br />
</p><div class="fragment"><div class="line"><a class="code" href="classbfn_1_1unique__map__ptr__x64.html#a433383f67c0c72788e9652c6f6d16631">reset</a>(other.release());</div></div><!-- fragment --><p>The <a class="el" href="classbfn_1_1unique__map__ptr__x64.html">unique_map_ptr_x64</a> provided will no longer be valid, and the new <a class="el" href="classbfn_1_1unique__map__ptr__x64.html">unique_map_ptr_x64</a> will have the mapping provided. Note that this should be a fast operation, and no mapping / unmapping occurs. If the existing mapping is invalid, or already unmapped, the resulting <a class="el" href="classbfn_1_1unique__map__ptr__x64.html">unique_map_ptr_x64</a> will also be invalid / unmapped.</p>
<dl class="section pre"><dt>Precondition</dt><dd>expects: none </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>ensures: none</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the <a class="el" href="classbfn_1_1unique__map__ptr__x64.html">unique_map_ptr_x64</a> to move </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="map__ptr__x64_8h_source.html#l00579">579</a> of file <a class="el" href="map__ptr__x64_8h_source.html">map_ptr_x64.h</a>.</p>

</div>
</div>
<a id="ab0b9ef217ee51e818ef3d1222905ec4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0b9ef217ee51e818ef3d1222905ec4f">&#9670;&nbsp;</a></span>~unique_map_ptr_x64()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbfn_1_1unique__map__ptr__x64.html">bfn::unique_map_ptr_x64</a>&lt; T &gt;::~<a class="el" href="classbfn_1_1unique__map__ptr__x64.html">unique_map_ptr_x64</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destructor</p>
<p>Unmaps any existing map this <a class="el" href="classbfn_1_1unique__map__ptr__x64.html">unique_map_ptr_x64</a> holds. Note that if an occurs while attempting to unmap, exceptions are caught and execution continues. If this occurs, the results are undefined.</p>
<dl class="section pre"><dt>Precondition</dt><dd>expects: none </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>ensures: none </dd></dl>

<p class="definition">Definition at line <a class="el" href="map__ptr__x64_8h_source.html#l00594">594</a> of file <a class="el" href="map__ptr__x64_8h_source.html">map_ptr_x64.h</a>.</p>

</div>
</div>
<a id="a8125d157b371250c4b4fb7148b11b340"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8125d157b371250c4b4fb7148b11b340">&#9670;&nbsp;</a></span>unique_map_ptr_x64() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbfn_1_1unique__map__ptr__x64.html">bfn::unique_map_ptr_x64</a>&lt; T &gt;::<a class="el" href="classbfn_1_1unique__map__ptr__x64.html">unique_map_ptr_x64</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbfn_1_1unique__map__ptr__x64.html">unique_map_ptr_x64</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ac1201a45bc0b5aa72807a120bd8bae82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1201a45bc0b5aa72807a120bd8bae82">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbfn_1_1unique__map__ptr__x64.html">unique_map_ptr_x64</a>&amp; <a class="el" href="classbfn_1_1unique__map__ptr__x64.html">bfn::unique_map_ptr_x64</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbfn_1_1unique__map__ptr__x64.html">unique_map_ptr_x64</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy Operator</p>
<p>Like std::unique_ptr, this is equivalent to</p>
<p><b>Example:</b> <br />
</p><div class="fragment"><div class="line"><a class="code" href="classbfn_1_1unique__map__ptr__x64.html#a433383f67c0c72788e9652c6f6d16631">reset</a>(other.release());</div></div><!-- fragment --><p>The <a class="el" href="classbfn_1_1unique__map__ptr__x64.html">unique_map_ptr_x64</a> provided will no longer be valid, and the new <a class="el" href="classbfn_1_1unique__map__ptr__x64.html">unique_map_ptr_x64</a> will have the mapping provided. Note that this should be a fast operation, and no mapping / unmapping occurs. If the existing mapping is invalid, or already unmapped, the resulting <a class="el" href="classbfn_1_1unique__map__ptr__x64.html">unique_map_ptr_x64</a> will also be invalid / unmapped.</p>
<dl class="section pre"><dt>Precondition</dt><dd>expects: none </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>ensures: none</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the <a class="el" href="classbfn_1_1unique__map__ptr__x64.html">unique_map_ptr_x64</a> to copy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to this </dd></dl>

<p class="definition">Definition at line <a class="el" href="map__ptr__x64_8h_source.html#l00625">625</a> of file <a class="el" href="map__ptr__x64_8h_source.html">map_ptr_x64.h</a>.</p>

</div>
</div>
<a id="a10ef62fb1160dac4c80c83830c395bfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10ef62fb1160dac4c80c83830c395bfe">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbfn_1_1unique__map__ptr__x64.html">unique_map_ptr_x64</a>&amp; <a class="el" href="classbfn_1_1unique__map__ptr__x64.html">bfn::unique_map_ptr_x64</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname"><em>dontcare</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy Operator (reset)</p>
<p>Like std::unique_ptr, this is equivalent to</p>
<p><b>Example:</b> <br />
</p><div class="fragment"><div class="line"><a class="code" href="classbfn_1_1unique__map__ptr__x64.html#a433383f67c0c72788e9652c6f6d16631">reset</a>();</div></div><!-- fragment --><p>The result of this operation is the current <a class="el" href="classbfn_1_1unique__map__ptr__x64.html">unique_map_ptr_x64</a> will be unmapped and invalid.</p>
<dl class="section pre"><dt>Precondition</dt><dd>expects: none </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>ensures: none</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dontcare</td><td>nullptr </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to this </dd></dl>

<p class="definition">Definition at line <a class="el" href="map__ptr__x64_8h_source.html#l00649">649</a> of file <a class="el" href="map__ptr__x64_8h_source.html">map_ptr_x64.h</a>.</p>

</div>
</div>
<a id="a9890b80c432fb80058ccb1cf782fb71f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9890b80c432fb80058ccb1cf782fb71f">&#9670;&nbsp;</a></span>operator*()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::add_lvalue_reference&lt;T&gt;::type <a class="el" href="classbfn_1_1unique__map__ptr__x64.html">bfn::unique_map_ptr_x64</a>&lt; T &gt;::operator* </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Dereference</p>
<p>Returns *T. Note that if the map is invalid, this operation will likely segfault.</p>
<dl class="section pre"><dt>Precondition</dt><dd>expects: none </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>ensures: none</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>*T </dd></dl>

<p class="definition">Definition at line <a class="el" href="map__ptr__x64_8h_source.html#l00667">667</a> of file <a class="el" href="map__ptr__x64_8h_source.html">map_ptr_x64.h</a>.</p>

</div>
</div>
<a id="a0c2d004a8504c2b552ead8d2abff0711"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c2d004a8504c2b552ead8d2abff0711">&#9670;&nbsp;</a></span>operator->()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classbfn_1_1unique__map__ptr__x64.html">bfn::unique_map_ptr_x64</a>&lt; T &gt;::operator-&gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Dereference</p>
<p>Returns *T. Note that if the map is invalid, this operation will likely segfault.</p>
<dl class="section pre"><dt>Precondition</dt><dd>expects: none </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>ensures: none</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>*T </dd></dl>

<p class="definition">Definition at line <a class="el" href="map__ptr__x64_8h_source.html#l00680">680</a> of file <a class="el" href="map__ptr__x64_8h_source.html">map_ptr_x64.h</a>.</p>

</div>
</div>
<a id="a782537f40e14898c99f4c9bdc178251f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a782537f40e14898c99f4c9bdc178251f">&#9670;&nbsp;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbfn_1_1unique__map__ptr__x64.html#af69513270b79d98429e0a2e5d3486aea">pointer</a> <a class="el" href="classbfn_1_1unique__map__ptr__x64.html">bfn::unique_map_ptr_x64</a>&lt; T &gt;::get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get *T</p>
<p>Returns *T. Note that if the map is invalid, any use of the result will likely segfault.</p>
<dl class="section pre"><dt>Precondition</dt><dd>expects: none </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>ensures: none</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>*T </dd></dl>

<p class="definition">Definition at line <a class="el" href="map__ptr__x64_8h_source.html#l00693">693</a> of file <a class="el" href="map__ptr__x64_8h_source.html">map_ptr_x64.h</a>.</p>

</div>
</div>
<a id="a8da8d875181dc76fa41827617d7ea27a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8da8d875181dc76fa41827617d7ea27a">&#9670;&nbsp;</a></span>operator bool()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbfn_1_1unique__map__ptr__x64.html">bfn::unique_map_ptr_x64</a>&lt; T &gt;::operator bool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check Validity</p>
<dl class="section pre"><dt>Precondition</dt><dd>expects: none </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>ensures: none</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>returns true if the map is valid, false otherwise </dd></dl>

<p class="definition">Definition at line <a class="el" href="map__ptr__x64_8h_source.html#l00703">703</a> of file <a class="el" href="map__ptr__x64_8h_source.html">map_ptr_x64.h</a>.</p>

</div>
</div>
<a id="a783ba038b80a655dd3c666e28bf60091"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a783ba038b80a655dd3c666e28bf60091">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbfn_1_1unique__map__ptr__x64.html#ad695851a02f6a2c3a864a65729a8d20d">size_type</a> <a class="el" href="classbfn_1_1unique__map__ptr__x64.html">bfn::unique_map_ptr_x64</a>&lt; T &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Size</p>
<dl class="section pre"><dt>Precondition</dt><dd>expects: none </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>ensures: none</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>returns the size of the map in bytes. Returns 0 if the map is invalid </dd></dl>

<p class="definition">Definition at line <a class="el" href="map__ptr__x64_8h_source.html#l00714">714</a> of file <a class="el" href="map__ptr__x64_8h_source.html">map_ptr_x64.h</a>.</p>

</div>
</div>
<a id="a1b35386d2de2c0604a6b33eb8a45013c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b35386d2de2c0604a6b33eb8a45013c">&#9670;&nbsp;</a></span>release()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classbfn_1_1unique__map__ptr__x64.html">bfn::unique_map_ptr_x64</a>&lt; T &gt;::release </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Release</p>
<p>Like std::unique_ptr, this releases the map from this <a class="el" href="classbfn_1_1unique__map__ptr__x64.html">unique_map_ptr_x64</a> and returns a std::tuple containing the virtual address and size of the map. It is left to the user of this function to either deliver the std::tuple to another <a class="el" href="classbfn_1_1unique__map__ptr__x64.html">unique_map_ptr_x64</a> via <a class="el" href="classbfn_1_1unique__map__ptr__x64.html#a433383f67c0c72788e9652c6f6d16631">reset()</a>, or manually unmap / free the virtual address</p>
<dl class="section note"><dt>Note</dt><dd>use with caution as this is an unsafe operation</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>expects: none </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>ensures: none</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>returns a std::tuple containing the virtual address and size of the map. The user must manually unmap / free this memory </dd></dl>

<p class="definition">Definition at line <a class="el" href="map__ptr__x64_8h_source.html#l00733">733</a> of file <a class="el" href="map__ptr__x64_8h_source.html">map_ptr_x64.h</a>.</p>

</div>
</div>
<a id="a433383f67c0c72788e9652c6f6d16631"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a433383f67c0c72788e9652c6f6d16631">&#9670;&nbsp;</a></span>reset() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbfn_1_1unique__map__ptr__x64.html">bfn::unique_map_ptr_x64</a>&lt; T &gt;::reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbfn_1_1unique__map__ptr__x64.html#af69513270b79d98429e0a2e5d3486aea">pointer</a>&#160;</td>
          <td class="paramname"><em>ptr</em> = <code><a class="el" href="classbfn_1_1unique__map__ptr__x64.html#af69513270b79d98429e0a2e5d3486aea">pointer</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbfn_1_1unique__map__ptr__x64.html#ad695851a02f6a2c3a864a65729a8d20d">size_type</a>&#160;</td>
          <td class="paramname"><em>size</em> = <code><a class="el" href="classbfn_1_1unique__map__ptr__x64.html#ad695851a02f6a2c3a864a65729a8d20d">size_type</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbfn_1_1unique__map__ptr__x64.html#ad695851a02f6a2c3a864a65729a8d20d">size_type</a>&#160;</td>
          <td class="paramname"><em>unaligned_size</em> = <code><a class="el" href="classbfn_1_1unique__map__ptr__x64.html#ad695851a02f6a2c3a864a65729a8d20d">size_type</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reset</p>
<p>Like std::unique_ptr, this resets the <a class="el" href="classbfn_1_1unique__map__ptr__x64.html">unique_map_ptr_x64</a>. If no args are provide, this function unmaps / frees the <a class="el" href="classbfn_1_1unique__map__ptr__x64.html">unique_map_ptr_x64</a> and the mapped memory becomes invalid. If a valid virtual address and size are provided, the current <a class="el" href="classbfn_1_1unique__map__ptr__x64.html">unique_map_ptr_x64</a> is unmapped and freed, and the newly provided virtual address and size are used in it's place.</p>
<dl class="section note"><dt>Note</dt><dd>use with caution as this is an unsafe operation</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>expects: none </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>ensures: none</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>pointer to virtual memory to use. Defaults to nullptr </td></tr>
    <tr><td class="paramname">size</td><td>the size of the virtual memory provided in bytes. Defaults to 0 </td></tr>
    <tr><td class="paramname">unaligned_size</td><td>the unaligned size of the virtual memory provided in bytes. Defaults to 0. In most cases this is the same thing as size, but if your using a map from CR3, and the virtual address is not page aligned, you must add lower(virt) </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="map__ptr__x64_8h_source.html#l00768">768</a> of file <a class="el" href="map__ptr__x64_8h_source.html">map_ptr_x64.h</a>.</p>

</div>
</div>
<a id="acc48a3d46e913ce14180120fac4a0e5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc48a3d46e913ce14180120fac4a0e5a">&#9670;&nbsp;</a></span>reset() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbfn_1_1unique__map__ptr__x64.html">bfn::unique_map_ptr_x64</a>&lt; T &gt;::reset </td>
          <td>(</td>
          <td class="paramtype">const std::tuple&lt; <a class="el" href="classbfn_1_1unique__map__ptr__x64.html#af69513270b79d98429e0a2e5d3486aea">pointer</a>, <a class="el" href="classbfn_1_1unique__map__ptr__x64.html#ad695851a02f6a2c3a864a65729a8d20d">size_type</a>, <a class="el" href="classbfn_1_1unique__map__ptr__x64.html#ad695851a02f6a2c3a864a65729a8d20d">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reset</p>
<p>Like std::unique_ptr, this resets the <a class="el" href="classbfn_1_1unique__map__ptr__x64.html">unique_map_ptr_x64</a>. If no args are provide, this function unmaps / frees the <a class="el" href="classbfn_1_1unique__map__ptr__x64.html">unique_map_ptr_x64</a> and the mapped memory becomes invalid. If a valid virtual address and size are provided, the current <a class="el" href="classbfn_1_1unique__map__ptr__x64.html">unique_map_ptr_x64</a> is unmapped and freed, and the newly provided virtual address and size are used in it's place.</p>
<dl class="section note"><dt>Note</dt><dd>use with caution as this is an unsafe operation</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>expects: none </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>ensures: none</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>std::tuple containing the virtual memory address and size in bytes of the new mapping to use. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="map__ptr__x64_8h_source.html#l00797">797</a> of file <a class="el" href="map__ptr__x64_8h_source.html">map_ptr_x64.h</a>.</p>

</div>
</div>
<a id="a0728bf963381142c8d31bc99015a0bab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0728bf963381142c8d31bc99015a0bab">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbfn_1_1unique__map__ptr__x64.html">bfn::unique_map_ptr_x64</a>&lt; T &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbfn_1_1unique__map__ptr__x64.html">unique_map_ptr_x64</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Swap</p>
<p>Swaps the mappings of one <a class="el" href="classbfn_1_1unique__map__ptr__x64.html">unique_map_ptr_x64</a> with another</p>
<dl class="section pre"><dt>Precondition</dt><dd>expects: none </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>ensures: none</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the <a class="el" href="classbfn_1_1unique__map__ptr__x64.html">unique_map_ptr_x64</a> to swap with </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="map__ptr__x64_8h_source.html#l00809">809</a> of file <a class="el" href="map__ptr__x64_8h_source.html">map_ptr_x64.h</a>.</p>

</div>
</div>
<a id="aa3a294d1d70206b3ef16fd2d00afaae0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3a294d1d70206b3ef16fd2d00afaae0">&#9670;&nbsp;</a></span>flush()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbfn_1_1unique__map__ptr__x64.html">bfn::unique_map_ptr_x64</a>&lt; T &gt;::flush </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Flush</p>
<p>Flushes the TLB entries associated with the virtual address ranges this <a class="el" href="classbfn_1_1unique__map__ptr__x64.html">unique_map_ptr_x64</a> holds. This is done automatically when mapping memory, but might be needed if this map is shared with another core whose TLB has not been properly flushed.</p>
<dl class="section pre"><dt>Precondition</dt><dd>expects: none </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>ensures: none </dd></dl>

<p class="definition">Definition at line <a class="el" href="map__ptr__x64_8h_source.html#l00826">826</a> of file <a class="el" href="map__ptr__x64_8h_source.html">map_ptr_x64.h</a>.</p>

</div>
</div>
<a id="a3ef33836dc768edc96db1761f489f16a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ef33836dc768edc96db1761f489f16a">&#9670;&nbsp;</a></span>cache_flush()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbfn_1_1unique__map__ptr__x64.html">bfn::unique_map_ptr_x64</a>&lt; T &gt;::cache_flush </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Cache Flush</p>
<p>Flushes the Cache associated with the virtual address ranges this <a class="el" href="classbfn_1_1unique__map__ptr__x64.html">unique_map_ptr_x64</a> holds. This is done automatically when unmapping memory, but might be needed manually by users</p>
<dl class="section pre"><dt>Precondition</dt><dd>expects: none </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>ensures: none </dd></dl>

<p class="definition">Definition at line <a class="el" href="map__ptr__x64_8h_source.html#l00842">842</a> of file <a class="el" href="map__ptr__x64_8h_source.html">map_ptr_x64.h</a>.</p>

</div>
</div>
<a id="a2ace82f1294845dab56ca65e79b3cc44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ace82f1294845dab56ca65e79b3cc44">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbfn_1_1unique__map__ptr__x64.html">unique_map_ptr_x64</a>&amp; <a class="el" href="classbfn_1_1unique__map__ptr__x64.html">bfn::unique_map_ptr_x64</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbfn_1_1unique__map__ptr__x64.html">unique_map_ptr_x64</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/user/hypervisor/bfvmm/include/memory_manager/<a class="el" href="map__ptr__x64_8h_source.html">map_ptr_x64.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Apr 28 2017 22:12:10 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
