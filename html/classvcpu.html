<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>vcpu Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">vcpu Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for vcpu:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classvcpu.png" usemap="#vcpu_map" alt=""/>
  <map id="vcpu_map" name="vcpu_map">
<area href="classvcpu__intel__x64.html" alt="vcpu_intel_x64" shape="rect" coords="0,56,97,80"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab4e211cbbbffbe964fd9c7924d0f640e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcpu.html#ab4e211cbbbffbe964fd9c7924d0f640e">vcpu</a> (<a class="el" href="namespacevcpuid.html#af2182a3f46c6c34675c42cfc98d67334">vcpuid::type</a> <a class="el" href="classvcpu.html#a45f745c4bc77c516f74278444dd90f1b">id</a>, std::unique_ptr&lt; <a class="el" href="classdebug__ring.html">debug_ring</a> &gt; <a class="el" href="misc__no__hyper_8cpp.html#a534de6dcaa9ced149edf28dfe3c01f2c">dr</a>=nullptr)</td></tr>
<tr class="separator:ab4e211cbbbffbe964fd9c7924d0f640e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d0f4f3ac4b7dba60f3596e145390adf"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcpu.html#a6d0f4f3ac4b7dba60f3596e145390adf">~vcpu</a> ()=default</td></tr>
<tr class="separator:a6d0f4f3ac4b7dba60f3596e145390adf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebd0bcd8756b33705a9f237f0edf080b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcpu.html#aebd0bcd8756b33705a9f237f0edf080b">init</a> (<a class="el" href="classuser__data.html">user_data</a> *<a class="el" href="test_2ioctl_8cpp.html#a818a5e36a128db8864b56ce84193d583">data</a>=nullptr)</td></tr>
<tr class="separator:aebd0bcd8756b33705a9f237f0edf080b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4b800150b1cb5e1a81934f2b340ed89"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcpu.html#ab4b800150b1cb5e1a81934f2b340ed89">fini</a> (<a class="el" href="classuser__data.html">user_data</a> *<a class="el" href="test_2ioctl_8cpp.html#a818a5e36a128db8864b56ce84193d583">data</a>=nullptr)</td></tr>
<tr class="separator:ab4b800150b1cb5e1a81934f2b340ed89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa73d5423f133ed568e8d11bf3dd2a094"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcpu.html#aa73d5423f133ed568e8d11bf3dd2a094">run</a> (<a class="el" href="classuser__data.html">user_data</a> *<a class="el" href="test_2ioctl_8cpp.html#a818a5e36a128db8864b56ce84193d583">data</a>=nullptr)</td></tr>
<tr class="separator:aa73d5423f133ed568e8d11bf3dd2a094"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84146467657e1df50945241c17686158"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcpu.html#a84146467657e1df50945241c17686158">hlt</a> (<a class="el" href="classuser__data.html">user_data</a> *<a class="el" href="test_2ioctl_8cpp.html#a818a5e36a128db8864b56ce84193d583">data</a>=nullptr)</td></tr>
<tr class="separator:a84146467657e1df50945241c17686158"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45f745c4bc77c516f74278444dd90f1b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacevcpuid.html#af2182a3f46c6c34675c42cfc98d67334">vcpuid::type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcpu.html#a45f745c4bc77c516f74278444dd90f1b">id</a> () const</td></tr>
<tr class="separator:a45f745c4bc77c516f74278444dd90f1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add09be92d4d1732cb2b5072baa0dcec0"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcpu.html#add09be92d4d1732cb2b5072baa0dcec0">is_running</a> ()</td></tr>
<tr class="separator:add09be92d4d1732cb2b5072baa0dcec0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a965a07d840d7b6d6fe566e0252f6baa2"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcpu.html#a965a07d840d7b6d6fe566e0252f6baa2">is_initialized</a> ()</td></tr>
<tr class="separator:a965a07d840d7b6d6fe566e0252f6baa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acded052e9cdf7bba97454b09052c953c"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcpu.html#acded052e9cdf7bba97454b09052c953c">is_bootstrap_vcpu</a> ()</td></tr>
<tr class="separator:acded052e9cdf7bba97454b09052c953c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7728f0daf16d280f225ed13a6be282c7"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcpu.html#a7728f0daf16d280f225ed13a6be282c7">is_host_vm_vcpu</a> ()</td></tr>
<tr class="separator:a7728f0daf16d280f225ed13a6be282c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae20da1a7f6db6fbedf620840cddc2f72"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcpu.html#ae20da1a7f6db6fbedf620840cddc2f72">is_guest_vm_vcpu</a> ()</td></tr>
<tr class="separator:ae20da1a7f6db6fbedf620840cddc2f72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9daa742650f0aa591d30eb5c69a474a2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcpu.html#a9daa742650f0aa591d30eb5c69a474a2">write</a> (const std::string &amp;str) <a class="el" href="vmx__intel__x64__mock_8cpp.html#a77ef1e3cf14f172741bc80b259147038">noexcept</a></td></tr>
<tr class="separator:a9daa742650f0aa591d30eb5c69a474a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac77b6306e2734b225784b24fb9bf2222"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcpu.html#ac77b6306e2734b225784b24fb9bf2222">vcpu</a> (<a class="el" href="classvcpu.html">vcpu</a> &amp;&amp;)=default</td></tr>
<tr class="separator:ac77b6306e2734b225784b24fb9bf2222"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a807089d195a6dbc4c96b56e8363f6f6e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcpu.html">vcpu</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcpu.html#a807089d195a6dbc4c96b56e8363f6f6e">operator=</a> (<a class="el" href="classvcpu.html">vcpu</a> &amp;&amp;)=default</td></tr>
<tr class="separator:a807089d195a6dbc4c96b56e8363f6f6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09e299c21405f1972cbaae79d01a9917"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcpu.html#a09e299c21405f1972cbaae79d01a9917">vcpu</a> (const <a class="el" href="classvcpu.html">vcpu</a> &amp;)=delete</td></tr>
<tr class="separator:a09e299c21405f1972cbaae79d01a9917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a478d30fedc58c2501924a06147cff34c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvcpu.html">vcpu</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvcpu.html#a478d30fedc58c2501924a06147cff34c">operator=</a> (const <a class="el" href="classvcpu.html">vcpu</a> &amp;)=delete</td></tr>
<tr class="separator:a478d30fedc58c2501924a06147cff34c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Virtual CPU</p>
<p>The vCPU represents a "core" for a virtual machine. There are different types of virtual machines (the host VM and guest VM being good examples) but in either case, a set of vCPUs must be provided.</p>
<p>For the host VM (also called the hardware domain), 1 vCPU must exist for each physical core. These vCPUs are special. Their IDs are their physical core nums as assigned by the host OS. This is because the "guest" part of the ID is 0. The resources these vCPUs are given should match the resources the host OS is using. Whether this is a type 1 or type 2 configuration, the host OS is usually the OS that is already running when the hypervisor is loaded. In a type 1 configuration, this is UEFI, which will later boot another OS (e.g. Windows, Linux or macOS) after the hypervisor is loaded. In a type 2 configuration, the host OS is the OS that is already running. Keep in mind that this is typically how it's done, but doesn't have to be the case. For example, in an embedded case, it might make sense to start from UEFI, and boot a separate control and hardware VM and never execute the UEFI instance ever again. Just depends on what your looking for. The goal here is to create a vCPU architecture that can support any configuration your looking for.</p>
<p>For a guest VM, there can be any number of vCPUs. The first half of the ID is the guest ID, and the second half of the ID is a unique identifier. The goal with Bareflank is to allow any number of virtual cores, regardless of the physical core configuration. To support this, vCPUs can be scheduled on any core, and the ID does not correlate with a physical core. It's up to the vCPU implementation to figure out how to schedule a core on the proper vCPU. In the case of Intel, this means that the VMCS class and the exit handler will have to store their own physical core ID that is different from the vCPU ID. If the exit handler has to schedule a VMCS and it detects the VMCS used to be on a different core, it will have to perform a transition.</p>
<p>This generic vCPU class not only provides the base class that architecture specific vCPUs will be created from, but it also provides some of the base functionality that is common between all vCPUs.</p>
<p>Each vCPU is given its own debug ring. The bootstrap core is a special core. All std::cout that is not wrapped in the output_to_vcpu function is redirected to serial and the bootstrap core, which is vcpuid == 0, or the first vCPU to be created on the host OS. Each debug ring provides a set of tags that can be used to identify the debug ring from a memory dump. The vCPU ID is also provided so that you can figure out which debug ring you're looking at.</p>
<p>The init, fini, run and hlt functions must be executed in the proper order. Each vCPU must be initialized and finalized. The destructor for the vCPU should not be used as destructors are labeled "noexcept" by default. Instead the init and fini functions act as constructors / destructors that can handle errors if they should arise. Doing this will also provide debugging support with the debug rings.</p>
<p>Note that these should not be created directly, but instead should be created by the <a class="el" href="classvcpu__manager.html">vcpu_manager</a>, which uses the <a class="el" href="classvcpu__factory.html">vcpu_factory</a> to actually create a vcpu. The <a class="el" href="classvcpu__factory.html">vcpu_factory</a> is provided by default, but should be overloaded by a Bareflank extension to provide custom logic on how to implement the hypervisor itself. It's in this function, that host-only, type 1 and type 2 hypervisors can be defined (including guest support). Also note that the vCPU is a base class. The <a class="el" href="classvcpu__factory.html">vcpu_factory</a> really should be creating architectural vCPUs as this class doesn't do much. </p>

<p class="definition">Definition at line <a class="el" href="vcpu_8h_source.html#l00094">94</a> of file <a class="el" href="vcpu_8h_source.html">vcpu.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ab4e211cbbbffbe964fd9c7924d0f640e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4e211cbbbffbe964fd9c7924d0f640e">&#9670;&nbsp;</a></span>vcpu() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vcpu::vcpu </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevcpuid.html#af2182a3f46c6c34675c42cfc98d67334">vcpuid::type</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classdebug__ring.html">debug_ring</a> &gt;&#160;</td>
          <td class="paramname"><em>dr</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor</p>
<p>Creates a vCPU with the provided id and debug ring. This constructor provides a means to override and replace the internal resources of the vCPU. Note that if one of the resources is set to nullptr, a default will be constructed in its place, providing a means to select which internal components to override.</p>
<dl class="section pre"><dt>Precondition</dt><dd>expects: none </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>ensures: none</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>the id of the vcpu </td></tr>
    <tr><td class="paramname">dr</td><td>the debug ring the vcpu should use. If you provide nullptr, a default debug ring will be created. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="vcpu_8cpp_source.html#l00025">25</a> of file <a class="el" href="vcpu_8cpp_source.html">vcpu.cpp</a>.</p>

</div>
</div>
<a id="a6d0f4f3ac4b7dba60f3596e145390adf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d0f4f3ac4b7dba60f3596e145390adf">&#9670;&nbsp;</a></span>~vcpu()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual vcpu::~vcpu </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destructor</p>
<dl class="section pre"><dt>Precondition</dt><dd>expects: none </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>ensures: none </dd></dl>

</div>
</div>
<a id="ac77b6306e2734b225784b24fb9bf2222"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac77b6306e2734b225784b24fb9bf2222">&#9670;&nbsp;</a></span>vcpu() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vcpu::vcpu </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcpu.html">vcpu</a> &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a09e299c21405f1972cbaae79d01a9917"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09e299c21405f1972cbaae79d01a9917">&#9670;&nbsp;</a></span>vcpu() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vcpu::vcpu </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvcpu.html">vcpu</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aebd0bcd8756b33705a9f237f0edf080b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebd0bcd8756b33705a9f237f0edf080b">&#9670;&nbsp;</a></span>init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vcpu::init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classuser__data.html">user_data</a> *&#160;</td>
          <td class="paramname"><em>data</em> = <code>nullptr</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Init vCPU</p>
<p>Initializes the vCPU. This function should only be run once. To re-execute this function, fini should be used first. Both init and fini are used in place of the constructor / destructor for some logic that certainly could generate an exception.</p>
<dl class="section note"><dt>Note</dt><dd>: subclasses must call this function if it's overridden</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>expects: none </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>ensures: none</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>user data that can be passed around as needed by extensions of Bareflank </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classvcpu__intel__x64.html#ace46669fe717beb27197611000f7bd4c">vcpu_intel_x64</a>.</p>

<p class="definition">Definition at line <a class="el" href="vcpu_8cpp_source.html#l00039">39</a> of file <a class="el" href="vcpu_8cpp_source.html">vcpu.cpp</a>.</p>

</div>
</div>
<a id="ab4b800150b1cb5e1a81934f2b340ed89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4b800150b1cb5e1a81934f2b340ed89">&#9670;&nbsp;</a></span>fini()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vcpu::fini </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classuser__data.html">user_data</a> *&#160;</td>
          <td class="paramname"><em>data</em> = <code>nullptr</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Fini vCPU</p>
<p>Finalizes the vCPU. This function should only be run once. To re-execute this function, init should be used first. Both init and fini are used in place of the constructor / destructor for some logic that certainly could generate an exception.</p>
<dl class="section note"><dt>Note</dt><dd>: subclasses must call this function if it's overridden</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>expects: none </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>ensures: none</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>user data that can be passed around as needed by extensions of Bareflank </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classvcpu__intel__x64.html#a0fc1f32b980581364b88572b20bbe740">vcpu_intel_x64</a>.</p>

<p class="definition">Definition at line <a class="el" href="vcpu_8cpp_source.html#l00047">47</a> of file <a class="el" href="vcpu_8cpp_source.html">vcpu.cpp</a>.</p>

</div>
</div>
<a id="aa73d5423f133ed568e8d11bf3dd2a094"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa73d5423f133ed568e8d11bf3dd2a094">&#9670;&nbsp;</a></span>run()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vcpu::run </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classuser__data.html">user_data</a> *&#160;</td>
          <td class="paramname"><em>data</em> = <code>nullptr</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Run</p>
<p>Executes the vCPU. The vCPU can be in two different states prior to executing this function. When the vCPU is first created, the run function "starts" the vCPU's execution from a default state. If the vCPU was halted, running the vCPU again "resumes" its execution. When a VM exit occurs, the exit handler might be asked by the control VM to schedule a different vCPU. When this happens, it will likely call this function.</p>
<dl class="section note"><dt>Note</dt><dd>: subclasses must call this function if it's overridden</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>expects: none </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>ensures: none</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>user data that can be passed around as needed by extensions of Bareflank </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classvcpu__intel__x64.html#af7dbc69f163a6d62047e2cce132fa824">vcpu_intel_x64</a>.</p>

<p class="definition">Definition at line <a class="el" href="vcpu_8cpp_source.html#l00058">58</a> of file <a class="el" href="vcpu_8cpp_source.html">vcpu.cpp</a>.</p>

</div>
</div>
<a id="a84146467657e1df50945241c17686158"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84146467657e1df50945241c17686158">&#9670;&nbsp;</a></span>hlt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vcpu::hlt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classuser__data.html">user_data</a> *&#160;</td>
          <td class="paramname"><em>data</em> = <code>nullptr</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Halt</p>
<p>Halts the vCPU. The process of "pausing" a vCPU occurs when a VM exit occurs, and the VM's state is saved. VM exits could occur for many reasons including an instruction needs to be emulated (e.g. cpuid), an interrupt has fired (e.g. the periodic interrupt), or the hlt instruction has executed (e.g. the OS running on the vCPU has gone into idle).</p>
<p>Since a VM exit pauses the vCPU, this function is designed to tear down the vCPU. In some cases this is not needed as deleting the vCPU's resources is enough, but in other cases, special actions must be taken on a complete tear down. A good example of this is the host-only case. On tear down, the VMM needs to promote the host OS back to root operation prior to disabling the hypervisor completely.</p>
<dl class="section note"><dt>Note</dt><dd>: subclasses must call this function if it's overridden</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>expects: none </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>ensures: none</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>user data that can be passed around as needed by extensions of Bareflank </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classvcpu__intel__x64.html#a5dff55294d2932f73f2c8c3c0f4cbe06">vcpu_intel_x64</a>.</p>

<p class="definition">Definition at line <a class="el" href="vcpu_8cpp_source.html#l00066">66</a> of file <a class="el" href="vcpu_8cpp_source.html">vcpu.cpp</a>.</p>

</div>
</div>
<a id="a45f745c4bc77c516f74278444dd90f1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45f745c4bc77c516f74278444dd90f1b">&#9670;&nbsp;</a></span>id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacevcpuid.html#af2182a3f46c6c34675c42cfc98d67334">vcpuid::type</a> vcpu::id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>vCPU Id</p>
<dl class="section pre"><dt>Precondition</dt><dd>expects: none </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>ensures: none</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the vCPU's id </dd></dl>

<p class="definition">Definition at line <a class="el" href="vcpu_8h_source.html#l00209">209</a> of file <a class="el" href="vcpu_8h_source.html">vcpu.h</a>.</p>

</div>
</div>
<a id="add09be92d4d1732cb2b5072baa0dcec0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add09be92d4d1732cb2b5072baa0dcec0">&#9670;&nbsp;</a></span>is_running()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool vcpu::is_running </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Is Running</p>
<dl class="section pre"><dt>Precondition</dt><dd>expects: none </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>ensures: none</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>true if the vCPU is running, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="vcpu_8h_source.html#l00219">219</a> of file <a class="el" href="vcpu_8h_source.html">vcpu.h</a>.</p>

</div>
</div>
<a id="a965a07d840d7b6d6fe566e0252f6baa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a965a07d840d7b6d6fe566e0252f6baa2">&#9670;&nbsp;</a></span>is_initialized()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool vcpu::is_initialized </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Is Initialized</p>
<dl class="section pre"><dt>Precondition</dt><dd>expects: none </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>ensures: none</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>true if the vCPU is initialized, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="vcpu_8h_source.html#l00229">229</a> of file <a class="el" href="vcpu_8h_source.html">vcpu.h</a>.</p>

</div>
</div>
<a id="acded052e9cdf7bba97454b09052c953c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acded052e9cdf7bba97454b09052c953c">&#9670;&nbsp;</a></span>is_bootstrap_vcpu()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool vcpu::is_bootstrap_vcpu </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Is Bootstrap vCPU</p>
<dl class="section pre"><dt>Precondition</dt><dd>expects: none </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>ensures: none</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>true if this vCPU is the bootstrap vCPU, false otherwise </dd></dl>

<p class="definition">Definition at line <a class="el" href="vcpu_8h_source.html#l00239">239</a> of file <a class="el" href="vcpu_8h_source.html">vcpu.h</a>.</p>

</div>
</div>
<a id="a7728f0daf16d280f225ed13a6be282c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7728f0daf16d280f225ed13a6be282c7">&#9670;&nbsp;</a></span>is_host_vm_vcpu()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool vcpu::is_host_vm_vcpu </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Is Host VM vCPU</p>
<dl class="section pre"><dt>Precondition</dt><dd>expects: none </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>ensures: none</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>true if this vCPU belongs to the host VM, false otherwise </dd></dl>

<p class="definition">Definition at line <a class="el" href="vcpu_8h_source.html#l00249">249</a> of file <a class="el" href="vcpu_8h_source.html">vcpu.h</a>.</p>

</div>
</div>
<a id="ae20da1a7f6db6fbedf620840cddc2f72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae20da1a7f6db6fbedf620840cddc2f72">&#9670;&nbsp;</a></span>is_guest_vm_vcpu()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool vcpu::is_guest_vm_vcpu </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Is Guest VM vCPU</p>
<dl class="section pre"><dt>Precondition</dt><dd>expects: none </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>ensures: none</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>true if this vCPU belongs to a guest VM, false otherwise </dd></dl>

<p class="definition">Definition at line <a class="el" href="vcpu_8h_source.html#l00259">259</a> of file <a class="el" href="vcpu_8h_source.html">vcpu.h</a>.</p>

</div>
</div>
<a id="a9daa742650f0aa591d30eb5c69a474a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9daa742650f0aa591d30eb5c69a474a2">&#9670;&nbsp;</a></span>write()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vcpu::write </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write to Debug Ring</p>
<p>Each vCPU has its own debug ring. If this is the bootstrap core (vcpuid == 0), all std::cout / std::cerr calls go to this vCPU. To redirect output to a core other than the bootstrap core, use the output_to_vcpu function in <a class="el" href="debug_8h.html">debug.h</a>.</p>
<p>Note that when using this function, output does not go to serial. This can cause issues when debugging a core specific problem that hangs the system (as getting the debug ring requires a running system). To overcome this issue, each debug ring has a unique tag that can be used to identify the debug ring from a memory dump. Right next to the tag is the vCPU's ID that can be used to identify which vCPU the debug ring belongs to. From there, one must simply manually parse the ring.</p>
<dl class="section pre"><dt>Precondition</dt><dd>expects: none </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>ensures: none</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to write to the debug ring. If the ring is bigger than DEBUG_RING_SIZE, the write is ignored. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="vcpu_8cpp_source.html#l00074">74</a> of file <a class="el" href="vcpu_8cpp_source.html">vcpu.cpp</a>.</p>

</div>
</div>
<a id="a807089d195a6dbc4c96b56e8363f6f6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a807089d195a6dbc4c96b56e8363f6f6e">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcpu.html">vcpu</a>&amp; vcpu::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvcpu.html">vcpu</a> &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a478d30fedc58c2501924a06147cff34c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a478d30fedc58c2501924a06147cff34c">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvcpu.html">vcpu</a>&amp; vcpu::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvcpu.html">vcpu</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/user/hypervisor/bfvmm/include/vcpu/<a class="el" href="vcpu_8h_source.html">vcpu.h</a></li>
<li>/home/user/hypervisor/bfvmm/src/vcpu/src/<a class="el" href="vcpu_8cpp_source.html">vcpu.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Apr 28 2017 18:36:26 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
