<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>memory_manager Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="classes.html"><span>Data&#160;Structure&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">memory_manager Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:acdcd9ab16e1e6b4d2b8a2f85826b2b88"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmemory__manager.html#acdcd9ab16e1e6b4d2b8a2f85826b2b88">~memory_manager</a> ()</td></tr>
<tr class="separator:acdcd9ab16e1e6b4d2b8a2f85826b2b88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace17d8f3d2b04f97e924ed6c0807a1c0"><td class="memItemLeft" align="right" valign="top">virtual int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmemory__manager.html#ace17d8f3d2b04f97e924ed6c0807a1c0">free_blocks</a> ()</td></tr>
<tr class="separator:ace17d8f3d2b04f97e924ed6c0807a1c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c2498ba7c72e918eb20ca5db634cf33"><td class="memItemLeft" align="right" valign="top">virtual void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmemory__manager.html#a9c2498ba7c72e918eb20ca5db634cf33">malloc</a> (size_t size)</td></tr>
<tr class="separator:a9c2498ba7c72e918eb20ca5db634cf33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad430e84f9a67e54d72f2d5966a8cfa3d"><td class="memItemLeft" align="right" valign="top">virtual void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmemory__manager.html#ad430e84f9a67e54d72f2d5966a8cfa3d">malloc_aligned</a> (size_t size, uint64_t alignment)</td></tr>
<tr class="separator:ad430e84f9a67e54d72f2d5966a8cfa3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2d09d907046c7c84265385feda0e3f1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmemory__manager.html#ac2d09d907046c7c84265385feda0e3f1">free</a> (void *ptr)</td></tr>
<tr class="separator:ac2d09d907046c7c84265385feda0e3f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf316780a79b972b5a6efa3a0ae16359"><td class="memItemLeft" align="right" valign="top">virtual void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmemory__manager.html#acf316780a79b972b5a6efa3a0ae16359">virt_to_phys</a> (void *virt)</td></tr>
<tr class="separator:acf316780a79b972b5a6efa3a0ae16359"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0956982ba51e2fe7c8203c29b431cdb7"><td class="memItemLeft" align="right" valign="top">virtual void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmemory__manager.html#a0956982ba51e2fe7c8203c29b431cdb7">phys_to_virt</a> (void *phys)</td></tr>
<tr class="separator:a0956982ba51e2fe7c8203c29b431cdb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe926dd2230306a2599982c9f9ff9578"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmemory__manager.html#afe926dd2230306a2599982c9f9ff9578">add_mdl</a> (<a class="el" href="structmemory__descriptor.html">memory_descriptor</a> *mdl, int64_t num)</td></tr>
<tr class="separator:afe926dd2230306a2599982c9f9ff9578"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a944719167db2d4caa1622c143d266bc0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmemory__manager.html#a944719167db2d4caa1622c143d266bc0">memory_manager</a> (const <a class="el" href="classmemory__manager.html">memory_manager</a> &amp;)=delete</td></tr>
<tr class="separator:a944719167db2d4caa1622c143d266bc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8360b834a32baa9539718774611dc85"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmemory__manager.html">memory_manager</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmemory__manager.html#ab8360b834a32baa9539718774611dc85">operator=</a> (const <a class="el" href="classmemory__manager.html">memory_manager</a> &amp;)=delete</td></tr>
<tr class="separator:ab8360b834a32baa9539718774611dc85"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a7eb87b382c2ee3afecf841963da59eeb"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmemory__manager.html">memory_manager</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmemory__manager.html#a7eb87b382c2ee3afecf841963da59eeb">instance</a> ()</td></tr>
<tr class="separator:a7eb87b382c2ee3afecf841963da59eeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The memory manager has two specific functions:</p><ul>
<li>malloc / free memory</li>
<li>virt_to_phys / phys_to_virt conversions</li>
</ul>
<p>To support malloc / free, the memory manager has a buffer that is created at compile time that is can pull from and provide to the rest of the VMM. If the memory manager runs out of memory, the system is halted. To increase memory, adjust the number of blocks that are reserved in <a class="el" href="constants_8h.html">constants.h</a>.</p>
<p>To support virt / phys mappings, the memory manager has an add_mdl function that is called by the driver entry. Each time the driver entry allocates memory for an ELF module, it must call add_mdl with a list of page mappings that tells the VMM how to convert from virt to phys and back. The memory manager uses this information to provide the VMM with the needed conversions.</p>
<p>Finally, this module also provides the libc functions that are needed by libc++ for new / delete. For this reason, this modules is required to get libc++ working, which is needed by, pretty much the rest of the VMM including the serial code. Therefore, if there is issues with the memory mamaner, the process of debugging the memory manager is not simple, as you must get rid of all of the other modules, and work with the memory manager directly until it's working as needed (i.e. why unit testing can be very helpful here). </p>

<p>Definition at line <a class="el" href="memory__manager_8h_source.html#l00056">56</a> of file <a class="el" href="memory__manager_8h_source.html">memory_manager.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="acdcd9ab16e1e6b4d2b8a2f85826b2b88"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual memory_manager::~memory_manager </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destructor </p>

<p>Definition at line <a class="el" href="memory__manager_8h_source.html#l00062">62</a> of file <a class="el" href="memory__manager_8h_source.html">memory_manager.h</a>.</p>

</div>
</div>
<a class="anchor" id="a944719167db2d4caa1622c143d266bc0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">memory_manager::memory_manager </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmemory__manager.html">memory_manager</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Disable the copy consturctor </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a7eb87b382c2ee3afecf841963da59eeb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmemory__manager.html">memory_manager</a> * memory_manager::instance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get Singleton Instance</p>
<p>Get an instance to the singleton class. </p>

<p>Definition at line <a class="el" href="memory__manager_8cpp_source.html#l00114">114</a> of file <a class="el" href="memory__manager_8cpp_source.html">memory_manager.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ace17d8f3d2b04f97e924ed6c0807a1c0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t memory_manager::free_blocks </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Free Blocks</p>
<p>This class can be used to determine the total number of free blocks that the memory mamnager has left. Using this function, you can determine how much memory has been allocated, as well as how much memory is free. Not that that, although this will tell you how much is free, it cannot tell you if that memory can be allocated, since the free blocks could be highly fragemented.</p>
<dl class="section return"><dt>Returns</dt><dd>number of free blocks. </dd></dl>

<p>Definition at line <a class="el" href="memory__manager_8cpp_source.html#l00121">121</a> of file <a class="el" href="memory__manager_8cpp_source.html">memory_manager.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9c2498ba7c72e918eb20ca5db634cf33"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * memory_manager::malloc </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Malloc</p>
<p>Allocates a block of size bytes of memory, returning a pointer to the beginning of the block. The content of the newly allocated block of memory is not initialized. If size is 0, this function returns 0. If the size if equal to MAX_PAGE_SIZE, the memory returned is guaranteed to be aligned to MAX_PAGE_SIZE. Although this function will accept any size granularity, the minimum size that will be allocated is always MAX_CACHE_LINE_SIZE.</p>
<p>Note that this function generally should not be used directly, but instead new / delete should be used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>the number of bytes to allocate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the starting address of the memory allocated. </dd></dl>

<p>Definition at line <a class="el" href="memory__manager_8cpp_source.html#l00133">133</a> of file <a class="el" href="memory__manager_8cpp_source.html">memory_manager.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad430e84f9a67e54d72f2d5966a8cfa3d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * memory_manager::malloc_aligned </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>alignment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Malloc Aligned</p>
<p>Allocates a block of size bytes of memory, returning a pointer to the beginning of the block. The content of the newly allocated block of memory is not initialized. If size is 0, this function returns 0. Although this function will accept any size granularity, the minimum size that will be allocated is always MAX_CACHE_LINE_SIZE.</p>
<p>Unlike malloc, this function allows the programmer to specify that desired alignment of memory. When possible, malloc should be used instead indirectly by using new / delete as these already provide MAX_PAGE_SIZE alignment.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>the number of bytes to allocate </td></tr>
    <tr><td class="paramname">alignment</td><td>the desired alignment </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the starting address of the memory allocated. </dd></dl>

<p>Definition at line <a class="el" href="memory__manager_8cpp_source.html#l00139">139</a> of file <a class="el" href="memory__manager_8cpp_source.html">memory_manager.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac2d09d907046c7c84265385feda0e3f1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void memory_manager::free </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Free</p>
<p>Deallocates a block of memory previously allocated by a call to malloc, making it available again for further allocations. If ptr does not point to memory that was previously allocated, the call is ignored. If ptr is 0, the call is also ignored. If ptr points to an offset into memory that was previously allocated by a call to malloc, this function will free all of the memory allocated.</p>
<p>Note that this function generally should not be used directly, but instead new / delete should be used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>a pointer to memory previously allocated using malloc. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="memory__manager_8cpp_source.html#l00209">209</a> of file <a class="el" href="memory__manager_8cpp_source.html">memory_manager.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="acf316780a79b972b5a6efa3a0ae16359"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * memory_manager::virt_to_phys </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>virt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Virtual Address To Physical Address</p>
<p>Given a virtual address, returns a physical address. If the memory manager does not have a memory descriptor for the provided address, or the provided address is 0, 0 is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">virt</td><td>virtual address to convert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>physical address </dd></dl>

<p>Definition at line <a class="el" href="memory__manager_8cpp_source.html#l00267">267</a> of file <a class="el" href="memory__manager_8cpp_source.html">memory_manager.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0956982ba51e2fe7c8203c29b431cdb7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * memory_manager::phys_to_virt </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>phys</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Physical Address To Virtual Address</p>
<p>Given a physical address, returns a virtual address. If the memory manager does not have a memory descriptor for the provided address, or the provided address is 0, 0 is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">phys</td><td>physical address to convert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>virtual address </dd></dl>

<p>Definition at line <a class="el" href="memory__manager_8cpp_source.html#l00282">282</a> of file <a class="el" href="memory__manager_8cpp_source.html">memory_manager.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="afe926dd2230306a2599982c9f9ff9578"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void memory_manager::add_mdl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmemory__descriptor.html">memory_descriptor</a> *&#160;</td>
          <td class="paramname"><em>mdl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds Memory Descriptor List</p>
<p>Adds a memory descriptor list to the memory manager. The memory descriptors are used by the memory manager to do address conversions and lookup memory access rights. Note that this function should only by called by the driver entry point prior to initialization.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mdl</td><td>a pointer to a memory descriptor array </td></tr>
    <tr><td class="paramname">num</td><td>the number of memory descriptors in the array</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">invalid_argument_error</td><td>thrown if mdl == 0 or num == 0 </td></tr>
    <tr><td class="paramname">invalid_mdl_error</td><td>thrown if a memory descriptor in the list is not the size of a page, if the virtual address is not page aligned, or if the physical address is not page aligned. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="memory__manager_8cpp_source.html#l00319">319</a> of file <a class="el" href="memory__manager_8cpp_source.html">memory_manager.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab8360b834a32baa9539718774611dc85"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmemory__manager.html">memory_manager</a>&amp; memory_manager::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmemory__manager.html">memory_manager</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Disable the copy operator </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/user/hypervisor/bfvmm/include/memory_manager/<a class="el" href="memory__manager_8h_source.html">memory_manager.h</a></li>
<li>/home/user/hypervisor/bfvmm/src/memory_manager/src/<a class="el" href="memory__manager_8cpp_source.html">memory_manager.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Apr 20 2016 18:22:04 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.12
</small></address>
</body>
</html>
