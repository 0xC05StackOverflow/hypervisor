<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Bareflank APIs (version 1.0.0)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Bareflank APIs (version 1.0.0) </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="pageTOC"></a>
Content</h1>
<ol type="1">
<li><a class="el" href="index.html#description">Description</a></li>
<li><a class="el" href="index.html#license">License</a></li>
<li><a class="el" href="index.html#unit_tests">Unit Tests</a></li>
<li><a class="el" href="index.html#extending_bareflank">Extending Bareflank</a></li>
<li><a class="el" href="index.html#vmm_reference">VMM Reference</a></li>
</ol>
<h1><a class="anchor" id="description"></a>
Description</h1>
<p>The Bareflank Hypervisor is an open source, lightweight hypervisor, lead by Assured Information Security, Inc. the provides the scaffolding needed to rapidly prototype hypervisor technologies. To ease development, Bareflank is written in C++, and includes support for exceptions and the C++ Standard Template Library (STL) via libc++. With the C++ STL, users can leverage shared pointers, complex data structures (e.g. hash tables, maps, lists, etc…), and several other modern C++ features. Existing open source hypervisors that are written in C are difficult to modify, and spend a considerable amount of time re-writing similar functionality instead of focusing on what matters most: hypervisor technologies. Furthermore, users can leverage inheritance to extend every part of the hypervisor to provide additional functionality above and beyond what is already provided.</p>
<p>To this end, Bareflank's primary goal is to remain simple, and minimalistic, providing only the scaffolding needed to construct more complete/complicated hypervisors including:</p><ul>
<li>Type 1 Hypervisors (like Xen)</li>
<li>Type 2 Hypervisors (like VirtualBox)</li>
<li>Host-Only Hypervisors (commonly used by anti-virus and rootkits)</li>
</ul>
<p>The core business logic will remain in the hypervisors that extend Bareflank, and not in Bareflank itself.</p>
<h1><a class="anchor" id="license"></a>
License</h1>
<p>To support Bareflank's design approach, the entire project is licensed under the GNU Lesser General Public License v2.1 (LGPL), specifically enabling users of the project to both contribute back to the project, but also create proprietary extensions if so desired. For more information please see:</p>
<p><a href="http://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html">GNU Lesser General Public License, version 2.1</a></p>
<h1><a class="anchor" id="unit_tests"></a>
Unit Tests</h1>
<p>In addition to Bareflank’s lightweight, modular design, the entire hypervisor has been written using test driven development. As such, all of Bareflank’s code comes complete with a set of unit tests to validate that the provided code works as expected.</p>
<p>To execute the unit tests, run: </p><div class="fragment"><div class="line">make</div><div class="line">make <a class="code" href="classunittest.html">unittest</a></div></div><!-- fragment --><p>Bareflank uses Hippomocks for mocking C/C++ functionality in the unit tests when needed. As such, Bareflank includes a version of Hippomocks that can be used by Bareflank extensions. For more information on how to use Hippomocks, checkout some of the existing unit tests in the bfvmm, as well as the following:</p>
<p><a href="http://hippomocks.com/Main_Page">Hippomocks</a></p>
<h1><a class="anchor" id="extending_bareflank"></a>
Extending Bareflank</h1>
<p>Bareflank's VMM is written as a set of ELF modules. Extending the VMM is as simple as adding / replacing the existing modules with new functionality. For example, suppose you want to prototype a new memory management algorithm for your hypervisor. Doing so is as simple as replacing the <a class="el" href="classmemory__manager.html">memory_manager</a> module with your own.</p>
<p>In most cases, your likely to be more interested in modifying the virtualization extension logic. Currently Bareflank supports Intel, but ARM and AMD are planned for future releases. The VMM is broken up into the following major components:</p>
<ul>
<li>Support Logic (memory manager, serial, libc++, etc...)</li>
<li>Virtual CPU Management</li>
<li>Virtualization Extension Logic</li>
</ul>
<p>The support logic enables the VMM environment. For example, libc++ provides std::cout for debugging which uses the <a class="el" href="classmemory__manager.html">memory_manager</a> to allocate memory, and the <a class="el" href="classserial__port__intel__x64.html">serial_port_intel_x64</a> / <a class="el" href="classdebug__ring.html">debug_ring</a> to output the resulting text to. The virtualization extension logic is responsible for setting up, and enabling virtualization. This logic is specific to the architecture your using. On Intel, this consists of the VMXON, VMCS, exit handler, and intrinsics logic.</p>
<p>To encapsulate the architectural specific logic, each architecture has it's own vCPU (for Intel this is <a class="el" href="classvcpu__intel__x64.html">vcpu_intel_x64</a>) that subclasses a generic vCPU (<a class="el" href="classvcpu.html">vcpu</a>) used by the <a class="el" href="classvcpu__manager.html">vcpu_manager</a>, and created by the <a class="el" href="classvcpu__factory.html">vcpu_factory</a>. The <a class="el" href="classvcpu__factory.html">vcpu_factory</a> is in it's own module, specifically so that users of Bareflank can replace this module with their own factory.</p>
<p>The process of extending Bareflank with custom virtualization logic, starts by subclassing the code you wish to extend. In this example we will extend the <a class="el" href="classexit__handler__intel__x64.html">exit_handler_intel_x64</a> to count the number of CPUIDs that have been executed, but you can subclass anything including the <a class="el" href="classvmxon__intel__x64.html">vmxon_intel_x64</a>, <a class="el" href="classvmcs__intel__x64.html">vmcs_intel_x64</a>, <a class="el" href="classintrinsics__intel__x64.html">intrinsics_intel_x64</a> logic, etc... Worst case, you can always outright provide your own modules for this same logic. Subclassing the code that Bareflank already provides allows you to leverage the existing scaffolding that Bareflank has, likely saving you some additional time.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>exit_handler_cpuidcount : <span class="keyword">public</span> <a class="code" href="classexit__handler__intel__x64.html">exit_handler_intel_x64</a></div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    exit_handler_cpuidcount() :</div><div class="line">        m_count(0)</div><div class="line">    { }</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> ~exit_handler_cpuidcount()</div><div class="line">    { <a class="code" href="bfvmm_2include_2debug_8h.html#acdeb1076f627a4f4ed8e9978381f4510">bfdebug</a> &lt;&lt; <span class="stringliteral">&quot;cpuid count = &quot;</span> &lt;&lt; m_count &lt;&lt; <a class="code" href="bfvmm_2include_2debug_8h.html#a13aa2fa2c4982590dce6471e0e918df2">bfendl</a>; }</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classexit__handler__intel__x64.html#a7630b1b1bd5026db1a0ea94f257fec86">handle_cpuid</a>()</div><div class="line">    {</div><div class="line">        m_count++;</div><div class="line">        <a class="code" href="classexit__handler__intel__x64.html#a7630b1b1bd5026db1a0ea94f257fec86">exit_handler_intel_x64::handle_cpuid</a>();</div><div class="line">    }</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    int64_t m_count;</div><div class="line">};</div></div><!-- fragment --><p>In this example, when the exit handler is first created, a "count" variable is created with an initial value of 0, and when the exit handler is destroyed, the exit handler prints out the count variable using Bareflank's std::cout shortcut "bfdebug" (which also adds some additional text and color for the developer). When the default exit handler's dispatch function is called, it will call "handle_cpuid" each time a CPUID instruction needs to be emulated. In this example, we overload this function and increment the count variable each time this function is called. Finally, we call the original handle_cpuid which provides the CPUID emulation for us. Note that you could also leave this last part out and emulate the CPUID instruction yourself.</p>
<p>The next step is to tell the VMM how to create your exit handler instead of the default one. To do this, you need to provide a new <a class="el" href="classvcpu__factory.html">vcpu_factory</a>. The <a class="el" href="classvcpu__manager.html">vcpu_manager</a> uses the <a class="el" href="classvcpu__factory.html">vcpu_factory</a> to create vCPUs. Thus providing a custom factory provides a means to provide custom logic here (and also provides a simple means for unit testing).</p>
<div class="fragment"><div class="line">std::shared_ptr&lt;vcpu&gt;</div><div class="line"><a class="code" href="classvcpu__factory.html#a53f09c54ecac3ba6cf08fa5567c56d4d">vcpu_factory::make_vcpu</a>(int64_t vcpuid)</div><div class="line">{</div><div class="line">    <span class="keywordflow">return</span> std::make_shared&lt;vcpu_intel_x64&gt;(vcpuid,</div><div class="line">                                            <span class="keyword">nullptr</span>,</div><div class="line">                                            <span class="keyword">nullptr</span>,</div><div class="line">                                            <span class="keyword">nullptr</span>,</div><div class="line">                                            std::make_shared&lt;exit_handler_cpuidcount&gt;(),</div><div class="line">                                            <span class="keyword">nullptr</span>);</div><div class="line">}</div></div><!-- fragment --><p>In this example, we leave all of the inputs to the vCPU as null except for our new exit handler. When the vCPU is created, the vcpu creates default objects for all arguments that are left null, and uses the arguments that are provided. Note that we use the existing <a class="el" href="classvcpu__intel__x64.html">vcpu_intel_x64</a>, but you could subclass this vCPU class and provide your own custom logic here too. It's entirely up to the developer on how much you wish to reuse vs. replace.</p>
<p>Finally, we must provide a new list of modules to BFM when starting the hypervisor. In this example, we simply need to replace the old <a class="el" href="classvcpu__factory.html">vcpu_factory</a> with our new one, but you could add as many new modules as you wish here.</p>
<div class="fragment"><div class="line"><span class="preprocessor"># Default Modules</span></div><div class="line"><span class="preprocessor">#</span></div><div class="line"><span class="preprocessor"># Note: The existing vcpu_factory module is commented out as we will be</span></div><div class="line"><span class="preprocessor"># providing our own.</span></div><div class="line"></div><div class="line">../../../bfvmm/bin/cross/libmemory_manager.so</div><div class="line">../../../bfvmm/bin/cross/libentry.so</div><div class="line">../../../bfvmm/bin/cross/libserial.so</div><div class="line">../../../bfvmm/bin/cross/libdebug_ring.so</div><div class="line">../../../bfvmm/bin/cross/libintrinsics.so</div><div class="line">../../../bfvmm/bin/cross/libvmxon.so</div><div class="line">../../../bfvmm/bin/cross/libvmcs.so</div><div class="line">../../../bfvmm/bin/cross/libvcpu.so</div><div class="line"><span class="preprocessor">#../../../bfvmm/bin/cross/libvcpu_factory.so</span></div><div class="line">../../../bfvmm/bin/cross/libexit_handler.so</div><div class="line">../../../bfvmm/bin/cross/libmisc.so</div><div class="line">../../../bfvmm/bin/cross/libc++.so</div><div class="line"></div><div class="line"><span class="preprocessor"># Custom Modules</span></div><div class="line"><span class="preprocessor">#</span></div><div class="line"><span class="preprocessor"># Note: This is where we provide our own vcpu_factory.</span></div><div class="line"></div><div class="line">../../../hypervisor_example_cpuidcount/bin/cross/libvcpu_factory_cpuidcount.so</div></div><!-- fragment --><p>Currently, Bareflank does not support out of tree compilation, so all code must be compiled in the Bareflank tree as it contains the build system. To support extensions, any root level folder named src_* or hypervisor_* will be compiled along with the rest of Bareflank. Users code can be cloned into Bareflank's root with one of these names, and will be compiled. To illustrate how this is done, Bareflank comes complete with two examples (the one described above, and a second example that extends the VMCS to add VPID support).</p>
<p><a href="https://github.com/Bareflank/hypervisor_example_vpid">Bareflank Hypervisor VPID Example</a> <br />
 <a href="https://github.com/Bareflank/hypervisor_example_cpuidcount">Bareflank Hypervisor CPUID Example</a></p>
<p>To run the CPUID example, start by cloning the example repo into Bareflank's root folder:</p>
<div class="fragment"><div class="line">cd ~/hypervisor</div><div class="line">git clone https:<span class="comment">//github.com/Bareflank/hypervisor_example_cpuidcount</span></div></div><!-- fragment --><p>Once the example repo is cloned, you can build the example, and the rest of Bareflank on Linux by running:</p>
<div class="fragment"><div class="line">make</div><div class="line">make linux_load</div></div><!-- fragment --><p>You can run the example on Linux by doing the following:</p>
<div class="fragment"><div class="line">make <a class="code" href="namespacecommand__line__parser__command.html#adb01c85ba13700fceeb3f156f9441a81aeed1d80b27789b35c8d1ac4cbf0f8836">load</a> MODULES=hypervisor_example_cpuidcount/bin/cpuidcount.modules</div><div class="line">make <a class="code" href="namespacecommand__line__parser__command.html#adb01c85ba13700fceeb3f156f9441a81a2bf84801076fddd8dd7c33a14ecdac57">start</a></div></div><!-- fragment --><p>Finally, to unload the hypervisor, run the following:</p>
<div class="fragment"><div class="line">make <a class="code" href="namespacecommand__line__parser__command.html#adb01c85ba13700fceeb3f156f9441a81abf38581c861a77c330bb48a4700e2613">stop</a></div><div class="line">make <a class="code" href="namespacecommand__line__parser__command.html#adb01c85ba13700fceeb3f156f9441a81a1ec0931a1d8f7448707819dd7f1b39cf">unload</a></div></div><!-- fragment --><h1><a class="anchor" id="vmm_reference"></a>
VMM Reference</h1>
<p>Bareflank's VMM is made up of the following components:</p>
<h2><a class="anchor" id="General"></a>
General</h2>
<p><a class="el" href="entry_8cpp.html#a1cd017588e4611bface6ed4e38da6c54">init_vmm</a> <br />
 <a class="el" href="entry_8cpp.html#a2f5e6f683fb1b2a8076560f026f1b215">start_vmm</a> <br />
 <a class="el" href="entry_8cpp.html#af49b886d1221d407231185990125d34a">stop_vmm</a> <br />
 <a class="el" href="classvcpu.html">vcpu</a> <br />
 <a class="el" href="classvcpu__factory.html">vcpu_factory</a> <br />
 <a class="el" href="classvcpu__manager.html">vcpu_manager</a> <br />
 <a class="el" href="classmemory__manager.html">memory_manager</a> <br />
 <a class="el" href="classcommit__or__rollback.html">commit_or_rollback</a> <br />
</p>
<h2><a class="anchor" id="Intel"></a>
x86_64 Specific</h2>
<p><a class="el" href="classintrinsics__x64.html">intrinsics_x64</a> <br />
 <a class="el" href="classintrinsics__intel__x64.html">intrinsics_intel_x64</a> <br />
 <a class="el" href="classvmxon__intel__x64.html">vmxon_intel_x64</a> <br />
 <a class="el" href="classexit__handler__intel__x64.html">exit_handler_intel_x64</a> <br />
 <a class="el" href="classvmcs__intel__x64.html">vmcs_intel_x64</a> <br />
 <a class="el" href="classvmcs__intel__x64__state.html">vmcs_intel_x64_state</a> <br />
 <a class="el" href="classvcpu__intel__x64.html">vcpu_intel_x64</a> <br />
</p>
<h2><a class="anchor" id="Unit"></a>
Testing</h2>
<p><a class="el" href="classunittest.html">unittest</a> <br />
 <a class="el" href="namespacebfn.html#a1add7b2fffc70c1b8984c26453106d86">bfn::mock_shared</a> <br />
 <a class="el" href="unittest_8h.html#ac33e7cdfb5d44a7a0f0ab552eb5c3c6a">EXPECT_TRUE</a> <br />
 <a class="el" href="unittest_8h.html#aeb6c7ae89f440c90c1a1815951c836da">EXPECT_FALSE</a> <br />
 <a class="el" href="unittest_8h.html#a9c49dd21a7e1b05fb6f563287399c9ca">EXPECT_EXCEPTION</a> <br />
 <a class="el" href="unittest_8h.html#a2730b3a93d346d35e207e73a400bb7dc">EXPECT_NO_EXCEPTION</a> <br />
 <a class="el" href="unittest_8h.html#ae9244bfbda562e8b798789b001993fa5">ASSERT_TRUE</a> <br />
 <a class="el" href="unittest_8h.html#a8197fa52f3538588d20d8af4834c9003">ASSERT_FALSE</a> <br />
 <a class="el" href="unittest_8h.html#ad1c1ecfa80376c7069e54efc1e0257ff">ASSERT_EXCEPTION</a> <br />
 <a class="el" href="unittest_8h.html#af003d391242c2859222d5dd5363cca08">ASSERT_NO_EXCEPTION</a> <br />
 <a class="el" href="unittest_8h.html#ac5b267c33fb2a8d74d050ec829f940dd">RUN_UNITTEST_WITH_MOCKS</a> <br />
 <a class="el" href="unittest_8h.html#a1ac46db0bbc4411faf9a1205c640fba4">RUN_ALL_TESTS</a> <br />
</p>
<h2><a class="anchor" id="Debugging"></a>
Debugging</h2>
<p><a class="el" href="bfvmm_2include_2debug_8h.html#afcb71e1fecba0a92915b9d8b382e45a0">bfinfo</a> <br />
 <a class="el" href="bfvmm_2include_2debug_8h.html#acdeb1076f627a4f4ed8e9978381f4510">bfdebug</a> <br />
 <a class="el" href="bfvmm_2include_2debug_8h.html#ab9ec61f4ad1fdcfa8e9857720b1cc484">bfwarning</a> <br />
 <a class="el" href="bfvmm_2include_2debug_8h.html#a819b9a3a733b92925c8a9e94c870446d">bferror</a> <br />
 <a class="el" href="bfvmm_2include_2debug_8h.html#adab16b096977fe547cef0fa9d3c63a07">bffatal</a> <br />
 <a class="el" href="bfvmm_2include_2debug_8h.html#a13aa2fa2c4982590dce6471e0e918df2">bfendl</a> <br />
 <a class="el" href="classdebug__ring.html">debug_ring</a> <br />
 <a class="el" href="classserial__port__intel__x64.html">serial_port_intel_x64</a> <br />
 </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Apr 20 2016 18:22:04 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.12
</small></address>
</body>
</html>
