<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Bareflank APIs (version 1.1.0)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Bareflank APIs (version 1.1.0) </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="pageTOC"></a>
Content</h1>
<ol type="1">
<li><a class="el" href="index.html#description">Description</a></li>
<li><a class="el" href="index.html#license">License</a></li>
<li><a class="el" href="index.html#unit_tests">Unit Tests</a></li>
<li><a class="el" href="index.html#extending_bareflank">Extending Bareflank</a></li>
<li><a class="el" href="index.html#vmm_reference">VMM Reference</a></li>
<li><a class="el" href="index.html#serial">Serial Setup</a></li>
</ol>
<h1><a class="anchor" id="description"></a>
Description</h1>
<p>The Bareflank Hypervisor is an open source, lightweight hypervisor, lead by Assured Information Security, Inc. that provides the scaffolding needed to rapidly prototype new hypervisors. To ease development, Bareflank is written in C++, and includes support for exceptions and the C++ Standard Template Library (STL) via libc++. With the C++ STL, users can leverage shared pointers, complex data structures (e.g. hash tables, maps, lists, etc…), and several other modern C++ features. Existing open source hypervisors that are written in C are difficult to modify, and spend a considerable amount of time re-writing similar functionality instead of focusing on what matters most: hypervisor technologies. Furthermore, users can leverage inheritance to extend every part of the hypervisor to provide additional functionality above and beyond what is already provided.</p>
<p>To this end, Bareflank's primary goal is to remain simple, and minimalistic, providing only the scaffolding needed to construct more complete/complicated hypervisors including:</p><ul>
<li>Type 1 Hypervisors (like Xen)</li>
<li>Type 2 Hypervisors (like VirtualBox)</li>
<li>Host-Only Hypervisors (commonly used by anti-virus and rootkits)</li>
</ul>
<p>The core business logic will remain in the hypervisors that extend Bareflank, and not in Bareflank itself.</p>
<h1><a class="anchor" id="license"></a>
License</h1>
<p>To support Bareflank's design approach, the entire project is licensed under the GNU Lesser General Public License v2.1 (LGPL), specifically enabling users of the project to both contribute back to the project, but also create proprietary extensions if so desired. For more information please see:</p>
<p><a href="http://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html">GNU Lesser General Public License, version 2.1</a></p>
<h1><a class="anchor" id="unit_tests"></a>
Unit Tests</h1>
<p>In addition to Bareflank’s lightweight, modular design, the entire hypervisor has been written using test driven development. As such, all of Bareflank’s code comes complete with a set of unit tests to validate that the provided code works as expected.</p>
<p>To execute the unit tests, run: </p><div class="fragment"><div class="line">make test</div></div><!-- fragment --><p>Bareflank uses Hippomocks for mocking C/C++ functionality in the unit tests when needed. As such, Bareflank includes a version of Hippomocks that can be used by Bareflank extensions. For more information on how to use Hippomocks, checkout some of the existing unit tests in the bfvmm, as well as the following:</p>
<p><a href="http://hippomocks.com/Main_Page">Hippomocks</a></p>
<h1><a class="anchor" id="extending_bareflank"></a>
Extending Bareflank</h1>
<p>Bareflank's VMM is written as a set of ELF modules. Extending the VMM is as simple as adding / replacing the existing modules with new functionality. For example, suppose you want to prototype a new memory management algorithm for your hypervisor. Doing so is as simple as replacing the <a class="el" href="classmemory__manager__x64.html">memory_manager_x64</a> module with your own.</p>
<p>In most cases, your likely to be more interested in modifying the virtualization extension logic. Currently Bareflank supports Intel, but ARM and AMD are planned for future releases. The VMM is broken up into the following major components:</p>
<ul>
<li>Support Logic (memory manager, serial, libc++, etc...)</li>
<li>Virtual CPU Management</li>
<li>Virtualization Extension Logic</li>
</ul>
<p>The support logic enables the VMM environment. For example, libc++ provides std::cout for debugging which uses the <a class="el" href="classmemory__manager__x64.html">memory_manager_x64</a> to allocate memory, and the <a class="el" href="classserial__port__intel__x64.html">serial_port_intel_x64</a> / <a class="el" href="classdebug__ring.html">debug_ring</a> to output the resulting text to. The virtualization extension logic is responsible for setting up, and enabling virtualization. This logic is specific to the architecture your using. On Intel, this consists of the VMXON, VMCS, exit handler, and intrinsics logic.</p>
<p>To encapsulate the architectural specific logic, each architecture has its own vCPU (for Intel this is <a class="el" href="classvcpu__intel__x64.html">vcpu_intel_x64</a>) that subclasses a generic vCPU (<a class="el" href="classvcpu.html">vcpu</a>) used by the <a class="el" href="classvcpu__manager.html">vcpu_manager</a>, and created by the <a class="el" href="classvcpu__factory.html">vcpu_factory</a>. The <a class="el" href="classvcpu__factory.html">vcpu_factory</a> is in its own module, specifically so that users of Bareflank can replace this module with their own factory.</p>
<p>The process of extending Bareflank with custom virtualization logic, starts by subclassing the code you wish to extend. In this example we will extend the <a class="el" href="classexit__handler__intel__x64.html">exit_handler_intel_x64</a> to count the number of CPUIDs that have been executed, but you can subclass anything including the <a class="el" href="classvmxon__intel__x64.html">vmxon_intel_x64</a>, <a class="el" href="classvmcs__intel__x64.html">vmcs_intel_x64</a>, intrinsics_intel_x64 logic, etc... Worst case, you can always outright provide your own modules for this same logic. Subclassing the code that Bareflank already provides, allows you to leverage the existing scaffolding that Bareflank has, likely saving you some additional time.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>exit_handler_cpuidcount : <span class="keyword">public</span> <a class="code" href="classexit__handler__intel__x64.html">exit_handler_intel_x64</a></div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line"></div><div class="line">    exit_handler_cpuidcount() :</div><div class="line">        m_count(0)</div><div class="line">    { }</div><div class="line"></div><div class="line">    ~exit_handler_cpuidcount()<span class="keyword"> override</span></div><div class="line"><span class="keyword">    </span>{ bfdebug &lt;&lt; <span class="stringliteral">&quot;cpuid count = &quot;</span> &lt;&lt; m_count &lt;&lt; bfendl; }</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="classexit__handler__intel__x64.html#a2841b513de1f9471b8f1b54f63dd0272">handle_exit</a>(<a class="code" href="namespaceintel__x64_1_1vmcs.html#a3d6b2ecb9978874c95387bda890c0c91">intel_x64::vmcs::value_type</a> reason)<span class="keyword"> override</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">        <span class="keywordflow">if</span> (reason == <a class="code" href="namespaceintel__x64_1_1vmcs_1_1exit__reason_1_1basic__exit__reason.html#abb19dafcfd89369118405a227d9970cc">vmcs::exit_reason::basic_exit_reason::cpuid</a>)</div><div class="line">            m_count++;</div><div class="line"></div><div class="line">        <a class="code" href="classexit__handler__intel__x64.html#a2841b513de1f9471b8f1b54f63dd0272">exit_handler_intel_x64::handle_exit</a>(reason);</div><div class="line">    }</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line"></div><div class="line">    int64_t m_count;</div><div class="line">};</div></div><!-- fragment --><p>In this example, when the exit handler is first created, a "count" variable is created with an initial value of 0, and when the exit handler is destroyed, the exit handler prints out the count variable using Bareflank's std::cout shortcut "bfdebug" (which also adds some additional text and color for the developer). When the default exit handler's dispatch function is called, it will call "handle_exit" each time a an instruction needs to be emulated. In this example, we overload this function and increment the count variable each time CPUID is called. Finally, we call the original handle_exit which provides the CPUID emulation for us. Note that you could also leave this last part out and emulate the CPUID instruction yourself.</p>
<p>The next step is to tell the VMM how to create your exit handler instead of the default one. To do this, you need to provide a new <a class="el" href="classvcpu__factory.html">vcpu_factory</a>. The <a class="el" href="classvcpu__manager.html">vcpu_manager</a> uses the <a class="el" href="classvcpu__factory.html">vcpu_factory</a> to create vCPUs. Thus providing a custom factory provides a means to provide custom logic here (and also provides a simple means for unit testing).</p>
<div class="fragment"><div class="line">std::unique_ptr&lt;vcpu&gt;</div><div class="line"><a class="code" href="classvcpu__factory.html#a77b347e7045a433f878ede6d5adafb02">vcpu_factory::make_vcpu</a>(<a class="code" href="namespacevcpuid.html#af2182a3f46c6c34675c42cfc98d67334">vcpuid::type</a> <a class="code" href="namespacevcpuid.html">vcpuid</a>, <a class="code" href="classuser__data.html">user_data</a> *<a class="code" href="linux_2ioctl__private_8cpp.html#a818a5e36a128db8864b56ce84193d583">data</a>)</div><div class="line">{</div><div class="line">    <span class="keyword">auto</span> &amp;&amp;my_exit_handler = std::make_unique&lt;exit_handler_cpuidcount&gt;();</div><div class="line"></div><div class="line">    (void) data;</div><div class="line">    <span class="keywordflow">return</span> std::make_unique&lt;vcpu_intel_x64&gt;(</div><div class="line">               vcpuid,</div><div class="line">               <span class="keyword">nullptr</span>,                         <span class="comment">// default debug_ring</span></div><div class="line">               <span class="keyword">nullptr</span>,                         <span class="comment">// default vmxon</span></div><div class="line">               <span class="keyword">nullptr</span>,                         <span class="comment">// default vmcs</span></div><div class="line">               std::move(my_exit_handler),</div><div class="line">               <span class="keyword">nullptr</span>,                         <span class="comment">// default vmm_state</span></div><div class="line">               <span class="keyword">nullptr</span>);                        <span class="comment">// default guest_state</span></div><div class="line">}</div></div><!-- fragment --><p>In this example, we leave all of the inputs to the vCPU as null except for our new exit handler. When the vCPU is created, the vcpu creates default objects for all arguments that are left null, and uses the arguments that are provided. Note that we use the existing <a class="el" href="classvcpu__intel__x64.html">vcpu_intel_x64</a>, but you could subclass this vCPU class and provide your own custom logic here too. It's entirely up to the developer on how much you wish to reuse vs. replace.</p>
<p>Finally, we must provide a new list of modules to BFM when starting the hypervisor. In this example, we simply need to replace the old <a class="el" href="classvcpu__factory.html">vcpu_factory</a> with our new one, but you could add as many new modules as you wish here. Note that we use the BUILD_ABS macro to simplify pathing. If you use the make shortcuts, Bareflank will convert these for you. If you run bfm manually, you will need to run the build_scripts/filter_module_file.sh script to convert the macros, or use absolute / relative pathing in your module file.</p>
<div class="fragment"><div class="line">{</div><div class="line">    <span class="stringliteral">&quot;modules&quot;</span> :</div><div class="line">    [</div><div class="line">        <span class="stringliteral">&quot;%BUILD_ABS%/sysroot_vmm/x86_64-vmm-elf/lib/libc++.so.1.0&quot;</span>,</div><div class="line">        <span class="stringliteral">&quot;%BUILD_ABS%/sysroot_vmm/x86_64-vmm-elf/lib/libc++abi.so.1.0&quot;</span>,</div><div class="line">        <span class="stringliteral">&quot;%BUILD_ABS%/sysroot_vmm/x86_64-vmm-elf/lib/libc.so&quot;</span>,</div><div class="line">        <span class="stringliteral">&quot;%BUILD_ABS%/makefiles/bfcrt/bin/cross/libbfcrt.so&quot;</span>,</div><div class="line">        <span class="stringliteral">&quot;%BUILD_ABS%/makefiles/bfunwind/bin/cross/libbfunwind.so&quot;</span>,</div><div class="line">        <span class="stringliteral">&quot;%BUILD_ABS%/makefiles/bfvmm/src/debug_ring/bin/cross/libdebug_ring.so&quot;</span>,</div><div class="line">        <span class="stringliteral">&quot;%BUILD_ABS%/makefiles/bfvmm/src/entry/bin/cross/libentry.so&quot;</span>,</div><div class="line">        <span class="stringliteral">&quot;%BUILD_ABS%/makefiles/bfvmm/src/exit_handler/bin/cross/libexit_handler.so&quot;</span>,</div><div class="line">        <span class="stringliteral">&quot;%BUILD_ABS%/makefiles/bfvmm/src/intrinsics/bin/cross/libintrinsics.so&quot;</span>,</div><div class="line">        <span class="stringliteral">&quot;%BUILD_ABS%/makefiles/bfvmm/src/memory_manager/bin/cross/libmemory_manager.so&quot;</span>,</div><div class="line">        <span class="stringliteral">&quot;%BUILD_ABS%/makefiles/bfvmm/src/misc/bin/cross/misc&quot;</span>,</div><div class="line">        <span class="stringliteral">&quot;%BUILD_ABS%/makefiles/bfvmm/src/serial/bin/cross/libserial.so&quot;</span>,</div><div class="line">        <span class="stringliteral">&quot;%BUILD_ABS%/makefiles/bfvmm/src/vcpu/bin/cross/libvcpu.so&quot;</span>,</div><div class="line">        <span class="stringliteral">&quot;%BUILD_ABS%/makefiles/bfvmm/src/vmcs/bin/cross/libvmcs.so&quot;</span>,</div><div class="line">        <span class="stringliteral">&quot;%BUILD_ABS%/makefiles/bfvmm/src/vmxon/bin/cross/libvmxon.so&quot;</span></div><div class="line">        <span class="stringliteral">&quot;%BUILD_ABS%/makefiles/hypervisor_example_cpuidcount/vcpu_factory_cpuidcount/bin/cross/libvcpu_factory_cpuidcount.so&quot;</span>,</div><div class="line">    ]</div><div class="line">}</div></div><!-- fragment --><p>Currently, Bareflank supports both in-tree and out-of-tree compilation. To use in-tree, simply place your code in a folder at Bareflank's root starting with hypervisor_* or src_* and run make. To perform out-of-tree compilation, configure your build with "-m" to point to your module file and "-e" to point to your extensions.</p>
<p><a href="https://github.com/Bareflank/hypervisor_example_vpid">Bareflank Hypervisor VPID Example</a> <br />
 <a href="https://github.com/Bareflank/hypervisor_example_cpuidcount">Bareflank Hypervisor CPUID Count Example</a></p>
<h1><a class="anchor" id="vmm_reference"></a>
VMM Reference</h1>
<p>Bareflank's VMM is made up of the following components:</p>
<h2><a class="anchor" id="General"></a>
General</h2>
<p><a class="el" href="misc__no__hyper__or__libcxx_8cpp.html#a4e847aefcd34dc612ce82ab058f8adf1">start_vmm</a> <br />
 <a class="el" href="misc__no__hyper__or__libcxx_8cpp.html#a07cc3ee65137d92449c749cef606e2c2">stop_vmm</a> <br />
 <a class="el" href="misc__no__hyper__or__libcxx_8cpp.html#a08be5aef9fe0066756e94a9dab82c877">add_md</a> <br />
 <a class="el" href="debug__ring_8cpp.html#a05bf4adedd5fd9e564000067df19086e">get_drr</a> <br />
 <a class="el" href="crt_8h.html#a421980cc02e952b9aa72142ff4ddc281">local_init</a> <br />
 <a class="el" href="crt_8h.html#af44928d9725b2d01f6f9bdceb82d32eb">local_fini</a> <br />
</p>
<h2><a class="anchor" id="VCPU"></a>
Management</h2>
<p><a class="el" href="classvcpu.html">vcpu</a> <br />
 <a class="el" href="classvcpu__factory.html">vcpu_factory</a> <br />
 <a class="el" href="classvcpu__manager.html">vcpu_manager</a> <br />
</p>
<h2><a class="anchor" id="Memory"></a>
Management</h2>
<p><a class="el" href="classmemory__manager__x64.html">memory_manager_x64</a> <br />
 <a class="el" href="classmem__pool.html">mem_pool</a> <a class="el" href="classbfn_1_1unique__map__ptr__x64.html">bfn::unique_map_ptr_x64</a> <a class="el" href="classpage__table__entry__x64.html">page_table_entry_x64</a> <a class="el" href="classpage__table__x64.html">page_table_x64</a> <a class="el" href="classroot__page__table__x64.html">root_page_table_x64</a></p>
<h2><a class="anchor" id="Intel"></a>
x86_64 Specific</h2>
<p><a class="el" href="classvcpu__intel__x64.html">vcpu_intel_x64</a> <br />
 <a class="el" href="classvmxon__intel__x64.html">vmxon_intel_x64</a> <br />
 <a class="el" href="classexit__handler__intel__x64.html">exit_handler_intel_x64</a> <br />
 <a class="el" href="classvmcs__intel__x64.html">vmcs_intel_x64</a> <br />
 <a class="el" href="classvmcs__intel__x64__state.html">vmcs_intel_x64_state</a> <br />
 <a class="el" href="classvmcs__intel__x64__vmm__state.html">vmcs_intel_x64_vmm_state</a> <a class="el" href="classvmcs__intel__x64__host__vm__state.html">vmcs_intel_x64_host_vm_state</a></p>
<h2><a class="anchor" id="Unit"></a>
Testing</h2>
<p><a class="el" href="classunittest.html">unittest</a> <br />
 <a class="el" href="namespacebfn.html#aeeaabca629a3d9d53426c33e6a703f8d">bfn::mock_unique</a> <br />
 <a class="el" href="namespacebfn.html#ae6006b8ca4440770894e2dfe1ba3c8e1">bfn::mock_shared</a> <br />
 <a class="el" href="unittest_8h.html#a6c5088edc16955b34d6a6b40a5c5a408">expect_true</a> <br />
 <a class="el" href="unittest_8h.html#a06439525b5142ff0a1aea4f27f13ade8">expect_false</a> <br />
 <a class="el" href="unittest_8h.html#a86faf297eb3f16a9cb7307e479be02f6">expect_exception</a> <br />
 <a class="el" href="unittest_8h.html#a52a4c4e9fced4c52753f129a4f62aec1">expect_no_exception</a> <br />
 <a class="el" href="unittest_8h.html#ac5b267c33fb2a8d74d050ec829f940dd">RUN_UNITTEST_WITH_MOCKS</a> <br />
 <a class="el" href="unittest_8h.html#a1ac46db0bbc4411faf9a1205c640fba4">RUN_ALL_TESTS</a> <br />
</p>
<h2><a class="anchor" id="Debugging"></a>
Debugging</h2>
<p><a class="el" href="classdebug__ring.html">debug_ring</a> <br />
 <a class="el" href="classserial__port__intel__x64.html">serial_port_intel_x64</a> <br />
</p>
<h1><a class="anchor" id="serial"></a>
Serial Setup</h1>
<p>With VMWare, Bareflank will use serial0 to output bfxxx / std::cout / std::cerr by default. On some VMWare systems, the printer uses serial0, so you might have to remove (disabling is not enough) the printer prior to adding the serial device. Worst case, you can modify the .vmx file manually to setup serial0.</p>
<p>On physical hardware however, you might have to define the serial port during compilation to something other than the default (or if you want to use a different VMWare serial port). To tell Bareflank to use a different port, you need to define the default port prior to compiling Bareflank.</p>
<p>export CROSS_CXXFLAGS="-DDEFAULT_COM_PORT=0x&lt;port #&gt;"</p>
<p>By default this is set to "COM1_PORT" or "0x3f8". You can set this to any of the following:</p><ul>
<li>com1_port</li>
<li>com2_port</li>
<li>com3_port</li>
<li>com4_port</li>
<li>0x&lt;port #&gt;</li>
</ul>
<p>On some Intel systems with PCI serial devices the port numbers are:</p><ul>
<li>0xe000</li>
<li>0xe010</li>
</ul>
<p>You can use the above method to define all of the parameters for serial as well. The default values are listed below, and you can change them to anything you wish:</p><ul>
<li>DEFAULT_COM_PORT=com1_port</li>
<li>DEFAULT_BAUD_RATE=baud_rate_115200</li>
<li>DEFAULT_DATA_BITS=char_length_8</li>
<li>DEFAULT_STOP_BITS=stop_bits_1</li>
<li>DEFAULT_PARITY_BITS=parity_none</li>
</ul>
<p>For more information, please see <a class="el" href="serial__port__intel__x64_8h.html">serial_port_intel_x64.h</a> </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Apr 28 2017 22:12:12 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
